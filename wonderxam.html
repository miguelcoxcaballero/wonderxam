<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=5.0">
    <title>Wonderxam</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'brand-copper': '#d97736',
                    },
                    fontFamily: {
                        'logo': ['"Comfortaa"', 'cursive'],
                    }
                }
            }
        }
    </script>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&family=Inconsolata:wght@400;700&family=Inter:wght@400;600&family=Lato:wght@400;700&family=Lexend:wght@300;400;600&family=Lora:ital,wght@0,400;0,600;1,400&family=Merriweather:wght@400;700&family=Montserrat:wght@400;600&family=Open+Sans:wght@400;600&family=Oswald:wght@400;600&family=Playfair+Display:wght@400;600&family=Roboto:wght@400;500;700&family=Comfortaa:wght@300;400;700&family=Google+Sans:wght@400;500;700&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,0,0" />

    <style>
        :root {
            --primary: #7c3aed; /* Purple */
            --bg: #f3f4f6;
            --surface: #ffffff;
            --text: #1f1f1f;
            --border: #e5e7eb;
            --brand-copper: #d97736;
        }

        /* Prevent scrolling on the document root */
        html, body, #root {
            margin: 0; 
            height: 100%; 
            width: 100%;
            overflow: hidden; 
            font-family: 'Roboto', sans-serif; 
            background-color: var(--bg);
            color: var(--text);
            user-select: none; 
        }
        
        input, textarea {
            user-select: text;
        }

        /* --- SCROLLBAR RESTORED TO ORIGINAL STYLE --- */
        ::-webkit-scrollbar {
            width: 14px;
            height: 14px;
            background-color: transparent;
        }
        ::-webkit-scrollbar-track {
            background-color: transparent;
        }
        ::-webkit-scrollbar-thumb {
            background-color: #dadce0;
            border-radius: 8px;
            border: 4px solid transparent;
            background-clip: content-box;
            transition: background-color 0.2s;
        }
        ::-webkit-scrollbar-thumb:hover {
            background-color: #bdc1c6;
        }

        input, textarea, button, select, .katex {
            font-family: inherit;
            font-size: inherit;
            color: inherit;
        }

        .mat-icon { font-family: 'Material Symbols Rounded'; font-size: 24px; vertical-align: middle; user-select: none; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        /* App Shell */
        .app-shell { 
            display: flex; 
            width: 100%; 
            height: 100%; 
            overflow: hidden; 
            padding: 0; 
            gap: 0; 
        }

        /* Main Area */
        .main-area { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            height: 100%; 
            position: relative; 
            background: var(--bg);
            border: none;
            overflow: hidden; 
            min-width: 0; 
        }

        .top-bar { height: 64px; display: flex; align-items: center; padding: 0 24px; background: var(--bg); border-bottom: 1px solid transparent; flex-shrink: 0; z-index: 300; position: relative; }
        .top-bar::after { content: ''; position: absolute; left: 0; right: 14px; bottom: -24px; height: 24px; background: linear-gradient(to bottom, var(--bg), transparent); pointer-events: none; }
        .doc-title { font-family: 'Google Sans', sans-serif; font-size: 20px; background: transparent; border: 1px solid transparent; padding: 6px 12px; border-radius: 8px; width: 100%; max-width: 400px; outline: none; transition: 0.2s; }
        .doc-title:hover { background: #e9d5ff; }
        .doc-title:focus { background: white; border-color: var(--primary); box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        
        /* Viewport */
        .viewport { 
            flex: 1;
            height: 100%; 
            overflow-y: auto;   /* vertical scrolling */
            overflow-x: hidden; /* hide horizontal */
            padding: 40px 0;    
            display: block; 
            width: 100%; 
            position: relative;
        }
        
        .zoom-outer-container {
            width: 100%;
            min-height: 100%;
            display: flex;
            justify-content: center;
            padding: 40px 0;
            box-sizing: border-box;
        }

        .pages-scale-wrapper { 
            display: flex; 
            flex-direction: column; 
            gap: 40px; 
            transform-origin: top center; 
        }

        .a4-page { width: 794px; height: 1123px; background: white; box-shadow: 0 2px 8px rgba(0,0,0,0.1); position: relative; overflow: visible; box-sizing: border-box; border-radius: 6px; }
        
        /* Grid Lines */
        .grid-lines { 
            position: absolute; 
            top: -10px; left: -10px; right: -10px; bottom: -10px;
            pointer-events: none; z-index: 0; 
            background-color: transparent;
            border: none; 
        }

        /* Occupied/Ghost Styles */
        .occupied-space {
            position: absolute;
            background-color: #e5e7eb; /* Gray */
            opacity: 0.5;
            border-radius: 12px;
            pointer-events: none;
            z-index: 1;
        }
        
        .snap-ghost {
            position: absolute;
            background-color: rgba(139, 92, 246, 0.2); /* Purple tint */
            border: 2px dashed var(--primary);
            border-radius: 12px;
            pointer-events: none;
            z-index: 50; 
            transition: all 0.1s;
        }
        .snap-ghost.invalid {
            background-color: rgba(239, 68, 68, 0.4); 
            border-color: #ef4444;
        }

        /* Sidebar */
        .sidebar { 
            width: 340px; 
            background: var(--surface); 
            border: 1px solid var(--border); 
            border-radius: 24px; 
            display: flex; 
            flex-direction: column; 
            z-index: 50; 
            padding: 20px 16px; 
            gap: 16px; 
            box-shadow: 0 4px 20px rgba(0,0,0,0.08); 
            margin: 16px 16px 16px 0; 
            height: calc(100vh - 32px);
            flex-shrink: 0;
        }
        
        .block-wrapper { 
            position: absolute; 
            background: white; 
            border: 1px solid transparent; 
            border-radius: 12px; 
            box-sizing: border-box; 
            display: flex; 
            flex-direction: column; 
            transition: left 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), 
                        top 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), 
                        width 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), 
                        height 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), 
                        transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), 
                        box-shadow 0.2s, 
                        opacity 0.2s; 
            z-index: 10; 
        }
        .block-wrapper:hover { background-color: #fafafa; border-color: #ddd; z-index: 100; box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
        .block-wrapper.dragging { transition: none !important; z-index: 1000 !important; box-shadow: 0 20px 40px rgba(124, 58, 237, 0.25) !important; border-color: var(--primary) !important; background: white; }
        
        /* Dragging/Resizing Invalid State */
        .block-wrapper.invalid, .block-wrapper.dragging.invalid {
            border-color: #ef4444 !important;
            background-color: #fff1f2 !important;
            box-shadow: 0 0 0 1px #ef4444, 0 10px 30px rgba(239, 68, 68, 0.2) !important;
        }

        .block-wrapper.active { border-color: var(--primary); box-shadow: 0 0 0 1px var(--primary), 0 8px 24px rgba(124, 58, 237, 0.15); z-index: 200; background: white; }
        
        /* Collision Highlight */
        .block-wrapper.collision-highlight { 
            background-color: #fee2e2 !important; 
            border: 2px solid #fca5a5 !important; 
            z-index: 200 !important; 
        }

        /* Updated Drag Handle: Outside Left & Larger */
        .drag-handle { 
            position: absolute; 
            left: -42px; 
            top: 0; 
            width: 36px; 
            height: 36px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            cursor: grab; 
            color: #9ca3af; 
            opacity: 0; 
            transition: 0.2s; 
            z-index: 50; 
            background: white; 
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .block-wrapper:hover .drag-handle { opacity: 1; }
        .block-wrapper.dragging .drag-handle { cursor: grabbing; }

        .delete-btn { position: absolute; right: 0; top: 0; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; cursor: pointer; color: #999; opacity: 0; transition: 0.2s; z-index: 50; }
        .delete-btn:hover { color: #d93025; background: #fce8e6; border-radius: 0 0 0 4px; }
        .block-wrapper:hover .delete-btn { opacity: 1; }
        .resize-handle { position: absolute; bottom: 0; right: 0; width: 16px; height: 16px; cursor: nwse-resize; opacity: 0; z-index: 50; }
        .resize-handle::after { content: ''; position: absolute; bottom: 3px; right: 3px; width: 6px; height: 6px; border-bottom: 2px solid var(--primary); border-right: 2px solid var(--primary); }
        .block-wrapper:hover .resize-handle { opacity: 1; }
        .resize-handle-h { cursor: ew-resize; }
        
        .tool-btn { width: 100%; padding: 10px 16px; border-radius: 8px; display: flex; align-items: center; gap: 12px; background: transparent; border: none; color: var(--text); font-family: 'Google Sans', sans-serif; font-size: 14px; font-weight: 500; cursor: pointer; transition: 0.2s; text-align: left; }
        .tool-btn:hover { background: #f3f4f6; }
        .tool-btn i { color: #5f6368; }
        .btn-primary { width: 100%; padding: 12px; border-radius: 24px; background: var(--primary); color: white; border: none; font-family: 'Google Sans', sans-serif; font-weight: 500; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .btn-primary:disabled { opacity: 0.7; cursor: default; }
        .fab { display: none; position: fixed; bottom: 24px; right: 24px; width: 56px; height: 56px; border-radius: 16px; background: var(--primary); color: white; border: none; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 1000; align-items: center; justify-content: center; cursor: pointer; }
        
        /* INHOUSE BADGE STYLES */
        .inhouse-badge {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            opacity: 0.6;
            transition: opacity 0.2s;
            text-decoration: none;
            color: var(--text-sub); 
            user-select: none;
            pointer-events: none;
        }
        .inhouse-badge svg {
            width: 24px;
            height: 14px;
            stroke-width: 6;
            stroke: #d97736; /* Brand Copper */
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        .inhouse-badge span {
            font-family: 'Comfortaa', cursive;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        /* --- HOME SCREEN STYLES --- */
        #homeScreen {
            position: absolute; inset: 0; z-index: 1000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: #fcf6f3;
            font-family: 'Roboto', sans-serif;
            animation: fadeIn 0.4s ease-out;
        }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; }}
        @keyframes heroEnter { from { opacity: 0; transform: translateY(30px); } to { opacity: 1; transform: translateY(0); } }

        .home-content {
            text-align: center;
            display: flex; flex-direction: column; align-items: center; gap: 24px;
            animation: heroEnter 0.8s cubic-bezier(0.2, 0.0, 0, 1.0);
            width: 100%; max-width: 600px;
        }

        .home-icon { font-size: 64px; color: #7c3aed; margin-bottom: 8px; }
        .home-title { font-family: 'Google Sans', sans-serif; font-size: 44px; font-weight: 400; color: #201a17; margin: 0; }
        .home-sub { font-size: 16px; color: #50453f; margin-top: -16px; margin-bottom: 16px; }

        .btn-home {
            height: 56px; padding: 0 32px; border-radius: 28px;
            background: #7c3aed; color: #ffffff;
            border: none; font-family: 'Google Sans', sans-serif; font-size: 16px; font-weight: 500;
            cursor: pointer; display: flex; align-items: center; gap: 12px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .btn-home:hover { transform: scale(1.02); box-shadow: 0 6px 12px rgba(0,0,0,0.15); }
        .btn-home:active { transform: scale(0.98); }

        #homeScreen .inhouse-badge {
            position: absolute; bottom: 32px; left: 50%; transform: translateX(-50%);
        }

        .texture-layer {
            position: fixed; inset: 0; background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.08'/%3E%3C/svg%3E");
            opacity: 0.4; pointer-events: none; z-index: -1; mix-blend-mode: overlay;
        }
        
        #bg-light-caster {
            position: absolute; top: 50%; left: 50%; width: 400px; height: 400px;
            background: radial-gradient(circle, rgba(124, 58, 237, 0.15) 0%, transparent 70%);
            border-radius: 50%; filter: blur(60px); transform: translate(-50%, -50%); pointer-events: none; z-index: 0;
        }

        /* --- NAMING MODAL --- */
        .modal-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 2000;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(4px);
            animation: fadeIn 0.2s ease-out;
        }
        .modal-card {
            background: white; width: 100%; max-width: 400px; padding: 24px; border-radius: 28px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            display: flex; flex-direction: column; gap: 24px;
            animation: heroEnter 0.3s var(--ease-spring);
        }
        .modal-title { font-family: 'Google Sans'; font-size: 24px; color: #1f1f1f; }
        .input-group { position: relative; }
        .mat-input {
            width: 100%; height: 56px; border: 1px solid #7c3aed;
            border-radius: 4px; background: transparent; padding: 0 16px;
            color: #1f1f1f; font-size: 16px; outline: none;
        }
        .input-label {
            position: absolute; left: 12px; top: -10px; background: white;
            padding: 0 4px; font-size: 12px; color: #7c3aed;
        }
        .modal-actions { display: flex; justify-content: flex-end; gap: 12px; }
        .btn-text {
            height: 40px; padding: 0 12px; border: none; background: transparent;
            color: #7c3aed; font-family: 'Google Sans'; font-weight: 500;
            cursor: pointer; border-radius: 20px; transition: 0.2s;
        }
        .btn-text:hover { background: rgba(124, 58, 237, 0.05); }
        .btn-fill {
            height: 40px; padding: 0 24px; border: none; border-radius: 20px;
            background: #7c3aed; color: white;
            font-family: 'Google Sans'; font-weight: 500; cursor: pointer; transition: 0.2s;
        }
        .btn-fill:hover { filter: brightness(1.1); }

        @media (max-width: 1024px) {
            .app-shell { flex-direction: column; padding: 0; gap: 0; }
            .main-area { border-radius: 0; border: none; }
            .sidebar { 
                display: none; 
                width: 100%; 
                border-radius: 24px 24px 0 0;
                border: none;
                box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
                margin: 0;
                height: auto;
            }
            .sidebar.open { 
                display: flex; 
                position: fixed; 
                bottom: 90px; 
                right: 24px; 
                width: 300px; 
                max-height: 60vh; 
                overflow-y: auto; 
                box-shadow: 0 8px 30px rgba(0,0,0,0.2); 
                animation: slideUp 0.2s ease; 
                border: 1px solid var(--border); 
                border-radius: 24px;
            }
            .fab { display: flex; }
            .top-bar { padding: 0 16px; }
            .viewport { padding: 20px 10px; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useLayoutEffect, useRef, useCallback, useMemo } = React;

        const MatIcon = ({ name, className="" }) => <span className={`mat-icon material-symbols-rounded ${className}`}>{name}</span>;

        // --- CONFIG ---
        const PX_PER_MM = 3.7795275591;
        const A4_W = 794; 
        const A4_H = 1123;
        const CELL = 37.8; // ~1cm
        const COLS = 18;
        const ROWS = 27; // Rows PER PAGE
        const MARGIN_X = (A4_W - (COLS * CELL)) / 2;
        const MARGIN_Y = (A4_H - (ROWS * CELL)) / 2;
        const PAGE_GAP = 40; // Gap between pages in px

        const FONTS = [
            { name: 'Lexend (Dyslexic)', val: "'Lexend', sans-serif" },
            { name: 'Roboto (Sans)', val: "'Roboto', sans-serif" },
            { name: 'Arial', val: "Arial, sans-serif" },
            { name: 'Calibri', val: "Calibri, sans-serif" },
            { name: 'Times New Roman', val: "'Times New Roman', serif" },
            { name: 'Open Sans', val: "'Open Sans', sans-serif" },
            { name: 'Lato', val: "'Lato', sans-serif" },
            { name: 'Montserrat', val: "'Montserrat', sans-serif" },
            { name: 'Inter', val: "'Inter', sans-serif" },
            { name: 'Lora (Serif)', val: "'Lora', serif" },
            { name: 'Merriweather', val: "'Merriweather', serif" },
            { name: 'Playfair Display', val: "'Playfair Display', serif" },
            { name: 'Inconsolata (Mono)', val: "'Inconsolata', monospace" },
            { name: 'Comic Neue (Dyslexic)', val: "'Comic Neue', cursive" },
        ];
        
        const FONT_SIZES = [
            { label: 'Small', val: 85 },
            { label: 'Normal', val: 100 },
            { label: 'Large', val: 125 }
        ];

        // --- NEW GRID COMPONENT FOR ANIMATED DOTS ---
        const GridLayer = React.memo(({ blocks, pageIndex, draggingBlockId }) => {
            const points = useMemo(() => {
                const pts = [];
                for (let r = 0; r <= ROWS; r++) {
                    for (let c = 0; c <= COLS; c++) {
                        pts.push({ c, r });
                    }
                }
                return pts;
            }, []);

            return (
                <div className="grid-layer absolute inset-0 pointer-events-none z-0">
                    {points.map((pt, i) => {
                        const globalRow = pageIndex * ROWS + pt.r;
                        const col = pt.c;
                        
                        let isCovered = false;
                        for (let b of blocks) {
                            if (draggingBlockId && b.id === draggingBlockId) continue;
                            if (
                                col >= b.x && col <= b.x + b.w &&
                                globalRow >= b.y && globalRow <= b.y + b.h
                            ) {
                                isCovered = true;
                                break;
                            }
                        }

                        return (
                            <div 
                                key={i}
                                style={{
                                    position: 'absolute',
                                    left: pt.c * CELL - 2,
                                    top: pt.r * CELL - 2,
                                    width: 4, 
                                    height: 4, 
                                    borderRadius: '50%', 
                                    backgroundColor: '#cbd5e1',
                                    opacity: isCovered ? 0 : 1,
                                    transition: 'opacity 0.4s ease',
                                    willChange: 'opacity'
                                }}
                            />
                        );
                    })}
                </div>
            );
        });

        // --- COMPONENTS ---

        const RichInput = ({ value, onChange, placeholder, minH="1.2em", image, onImg, contentRef, className="" }) => {
            const innerRef = useRef(null);
            const ref = contentRef || innerRef; 

            useLayoutEffect(() => {
                if(ref.current) {
                    ref.current.style.height = 'auto';
                    ref.current.style.height = ref.current.scrollHeight + 'px';
                }
            }, [value]);

            return (
                <div className="w-full flex flex-col group/input relative">
                    <div className="flex-1 flex items-start gap-2">
                        <textarea 
                            ref={ref}
                            rows={1}
                            className={`w-full bg-transparent outline-none resize-none hide-on-export overflow-hidden p-0 leading-normal ${className}`}
                            placeholder={placeholder} value={value} onChange={e=>onChange(e.target.value)}
                            style={{minHeight: minH, lineHeight: '1.5em'}}
                        />
                        <div className="export-only w-full whitespace-pre-wrap leading-normal" style={{minHeight: minH, lineHeight: '1.5em'}}>{value}</div>
                        
                        {onImg && (
                            <div className="absolute right-0 top-0 opacity-0 group-hover/input:opacity-100 transition no-export z-10">
                                <button onClick={()=>f.current.click()} className="p-1 bg-white rounded shadow hover:text-purple-600"><MatIcon name="image"/></button>
                                <input type="file" ref={f} hidden accept="image/*" onChange={e=>{if(e.target.files[0]){const r=new FileReader();r.onload=ev=>onImg(ev.target.result);r.readAsDataURL(e.target.files[0]);}}} />
                            </div>
                        )}
                    </div>
                    {image && (
                        <div className="mt-1 relative inline-block">
                            <img src={image} className="max-h-24 rounded border shadow-sm" />
                            <button onClick={()=>onImg(null)} className="absolute -top-2 -right-2 bg-white rounded-full shadow p-1 text-red-500 no-export"><MatIcon name="close"/></button>
                        </div>
                    )}
                </div>
            );
        };

        const BlockContent = ({ b, update, fontSizeMultiplier, handleAutoResize, isResizing, setContentOverflow, maxAvailableH }) => {
            const contentRef = useRef(null);
            
            useLayoutEffect(() => {
                if (!contentRef.current || ['line', 'image', 'space'].includes(b.type)) return;
                
                const timer = setTimeout(() => {
                    if (!contentRef.current) return;
                    const scrollH = contentRef.current.scrollHeight;
                    const currentHeightPx = b.h * CELL;
                    const isOverflowing = scrollH > currentHeightPx + 4;
                    
                    if (setContentOverflow) {
                        setContentOverflow(b.id, isOverflowing);
                    }

                    if (!isResizing && isOverflowing) {
                        const neededRows = Math.ceil((scrollH + 8) / CELL);
                        if (neededRows > b.h) {
                            handleAutoResize(b.id, neededRows);
                        }
                    }
                }, 10);
                return () => clearTimeout(timer);
            }, [b.data, fontSizeMultiplier, b.w, b.h, isResizing]); 

            const canAddOption = !isResizing && !(b.h >= ROWS);

            switch(b.type) {
                case 'header': return (
                    <div ref={contentRef} className="p-1 flex flex-col gap-4">
                        <div className="flex gap-3">
                            <div className="w-16 h-16 border border-dashed rounded flex items-center justify-center bg-gray-50 shrink-0 relative group">
                                {b.data.logo ? <img src={b.data.logo} className="w-full h-full object-contain"/> : <span className="text-gray-400" style={{fontSize: '0.75em'}}>LOGO</span>}
                                <input type="file" className="absolute inset-0 opacity-0 cursor-pointer" onChange={e=>{if(e.target.files[0]){const r=new FileReader();r.onload=ev=>update(b.id, {data:{...b.data, logo:ev.target.result}});r.readAsDataURL(e.target.files[0]);}}}/>
                            </div>
                            <div className="flex-1 flex flex-col gap-1">
                                <input className="font-bold bg-transparent outline-none w-full" style={{fontSize: '1.4em'}} placeholder="Institution" value={b.data.inst} onChange={e=>update(b.id, {data:{...b.data, inst:e.target.value}})}/>
                                <input className="bg-transparent outline-none w-full" style={{fontSize: '1.1em'}} placeholder="Exam Name" value={b.data.title} onChange={e=>update(b.id, {data:{...b.data, title:e.target.value}})}/>
                            </div>
                        </div>
                        <div className="grid grid-cols-2 gap-4 border-t pt-2" style={{fontSize: '0.75em'}}>
                            {['Name','Date','Class','Score'].map(l=><div key={l} className="flex gap-1"><span className="font-bold">{l}:</span><div className="flex-1 border-b border-dashed border-gray-400"></div></div>)}
                        </div>
                    </div>
                );
                case 'text': return <div className="p-1 h-full"><RichInput contentRef={contentRef} value={b.data.text} onChange={v=>update(b.id,{data:{...b.data, text:v}})} placeholder="Instructions..." /></div>;
                case 'line': return <div className="w-full h-full flex items-center justify-center px-2"><div className="w-full border-b border-black"></div></div>;
                case 'image': return (
                    <div className="w-full h-full bg-gray-50 flex items-center justify-center relative group">
                        {b.data.src ? <img src={b.data.src} className="w-full h-full object-contain"/> : <span className="text-gray-400" style={{fontSize: '0.75em'}}>Upload Image</span>}
                        {!b.data.src && <input type="file" className="absolute inset-0 opacity-0 cursor-pointer" onChange={e=>{if(e.target.files[0]){const r=new FileReader();r.onload=ev=>update(b.id,{data:{...b.data,src:ev.target.result}});r.readAsDataURL(e.target.files[0]);}}} />}
                    </div>
                );
                case 'mcq': return (
                    <div ref={contentRef} className="p-1 flex flex-col">
                        <div className="flex gap-2 mb-1 items-baseline">
                            <input className="w-6 font-bold bg-transparent outline-none text-right pt-1.5" value={b.data.num} onChange={e=>update(b.id,{data:{...b.data,num:e.target.value}})}/>
                            <div className="flex-1">
                                <RichInput 
                                    value={b.data.q} 
                                    onChange={v=>update(b.id,{data:{...b.data,q:v}})} 
                                    placeholder="Question"
                                    className="border-b border-transparent focus:border-purple-300"
                                />
                            </div>
                        </div>
                        <div className="pl-8 flex-1 flex flex-col gap-0">
                            {b.data.opts.map((o,i)=>(
                                <div key={i} className="flex items-start gap-2 group/opt">
                                    <div className="w-4 h-4 border border-gray-400 bg-white mt-1 shrink-0"></div>
                                    <span className="font-bold mt-0.5" style={{fontSize: '0.8em'}}>{String.fromCharCode(65+i)}.</span>
                                    <div className="flex-1">
                                        <RichInput 
                                            value={o} 
                                            onChange={v=>{const n=[...b.data.opts];n[i]=v;update(b.id,{data:{...b.data,opts:n}})}} 
                                            minH="1.2em"
                                            className="border-b border-transparent focus:border-purple-300"
                                        />
                                    </div>
                                    <button onClick={() => {
                                        const n = b.data.opts.filter((_, idx) => idx !== i);
                                        update(b.id, {data: {...b.data, opts: n}});
                                    }} className="text-gray-300 hover:text-red-500 transition-colors opacity-0 group-hover/opt:opacity-100 no-export mt-1">
                                        <MatIcon name="close" className="text-[16px]" />
                                    </button>
                                </div>
                            ))}
                            <button 
                                className={`text-left no-export transition-colors ${canAddOption ? 'text-purple-600 hover:text-purple-800' : 'text-gray-400 cursor-not-allowed'}`}
                                style={{fontSize: '0.8em'}} 
                                onClick={()=>{
                                    if(canAddOption) {
                                        const n=[...b.data.opts,''];
                                        update(b.id,{data:{...b.data,opts:n}})
                                    }
                                }}
                                title={!canAddOption ? "Not enough space to add option" : "Add Option"}
                            >+ Option</button>
                        </div>
                    </div>
                );
                case 'short': return (
                    <div ref={contentRef} className="p-1 flex flex-col">
                        <div className="flex gap-2 mb-1 items-baseline">
                            <input className="w-6 font-bold bg-transparent outline-none text-right p-0 m-0 leading-[1.5em]" value={b.data.num} onChange={e=>update(b.id,{data:{...b.data,num:e.target.value}})}/>
                            <div className="flex-1"><RichInput value={b.data.q} onChange={v=>update(b.id,{data:{...b.data,q:v}})} placeholder="Question"/></div>
                        </div>
                    </div>
                );
                case 'tf': return (
                    <div ref={contentRef} className="p-1 flex flex-col">
                        <div className="flex gap-2 mb-1 items-baseline">
                            <input className="w-6 font-bold bg-transparent outline-none text-right p-0 m-0 leading-[1.5em]" value={b.data.num} onChange={e=>update(b.id,{data:{...b.data,num:e.target.value}})}/>
                            <div className="flex-1"><RichInput value={b.data.q} onChange={v=>update(b.id,{data:{...b.data,q:v}})} placeholder="Statement"/></div>
                        </div>
                        <div className="pl-8 mt-2 flex gap-6" style={{fontSize: '0.8em'}}>
                            <div className="flex items-center gap-2">
                                <div className="w-4 h-4 border border-gray-400 bg-white"></div> <span>True</span>
                            </div>
                            <div className="flex items-center gap-2">
                                <div className="w-4 h-4 border border-gray-400 bg-white"></div> <span>False</span>
                            </div>
                        </div>
                    </div>
                );
            }
        };

        // --- EXAM EDITOR COMPONENT ---
        const ExamEditor = ({ initialTitle }) => {
            const [blocks, setBlocks] = useState([]);
            const [docStyle, setDocStyle] = useState({ font: FONTS[0].val, size: 100 });
            const [zoom, setZoom] = useState(1);
            const [sidebarOpen, setSidebarOpen] = useState(false);
            const [exporting, setExporting] = useState(false);
            const [title, setTitle] = useState(initialTitle || "Untitled Exam");
            const [overflowMap, setOverflowMap] = useState({});

            const containerRef = useRef(null);
            
            const [drag, setDrag] = useState({ 
                active: false, 
                id: null, 
                mode: null, 
                startX: 0, 
                startY: 0, 
                origX: 0, 
                origY: 0, 
                origW: 0, 
                origH: 0,
                resizeW: 0,
                resizeH: 0,
                snapX: 0,
                snapY: 0,
                deltaX: 0, 
                deltaY: 0,
                isValid: true,
                collidingIds: [] 
            });

            const getMaxHeight = useCallback((b) => {
                const p = Math.floor(b.y / ROWS);
                const pageEnd = (p + 1) * ROWS;
                let limit = pageEnd - b.y; 
                return 1000; 
            }, [blocks]);

            useLayoutEffect(() => {
                const fit = () => {
                    if(!containerRef.current) return;
                    const w = containerRef.current.clientWidth;
                    const horizontalPadding = 40; 
                    const fullPageWidth = A4_W + horizontalPadding;

                    if (w < fullPageWidth) {
                        const rawScale = (w - horizontalPadding) / A4_W;
                        const safeScale = Math.max(0.1, rawScale * 0.97); 
                        setZoom(safeScale);
                    } else {
                        setZoom(1);
                    }
                };
                window.addEventListener('resize', fit);
                fit();
                return () => window.removeEventListener('resize', fit);
            }, []);

            const totalPages = useMemo(() => {
                let maxY = 0;
                blocks.forEach(b => { if(b.y + b.h > maxY) maxY = b.y + b.h; });
                return Math.max(1, Math.ceil(maxY / ROWS));
            }, [blocks]);

            const getPage = (y) => Math.floor(y / ROWS);

            const handleContentOverflow = useCallback((id, isOverflowing) => {
                setOverflowMap(prev => {
                    if (prev[id] === isOverflowing) return prev;
                    return { ...prev, [id]: isOverflowing };
                });
            }, []);

            const handleAutoResize = (id, newH) => {
                const clampedH = Math.min(newH, ROWS);
                
                setBlocks(prev => {
                    const idx = prev.findIndex(b => b.id === id);
                    if(idx === -1) return prev;
                    
                    const b = prev[idx];
                    if(b.h === clampedH) return prev;

                    const newBlocks = JSON.parse(JSON.stringify(prev));
                    const block = newBlocks[idx];
                    block.h = clampedH;
                    
                    const currentRow = block.y;
                    const pageIndex = Math.floor(currentRow / ROWS);
                    const pageStart = pageIndex * ROWS;
                    const pageEnd = (pageIndex + 1) * ROWS;
                    
                    if (currentRow + clampedH > pageEnd) {
                        if (currentRow !== pageStart) {
                             block.y = (pageIndex + 1) * ROWS;
                        }
                    }

                    const pushDown = (pusherId) => {
                        const pusher = newBlocks.find(x => x.id === pusherId);
                        
                        newBlocks.forEach(victim => {
                            if (victim.id === pusher.id) return;
                            const isHorizOverlapping = !(victim.x + victim.w <= pusher.x || victim.x >= pusher.x + pusher.w);
                            if (isHorizOverlapping) {
                                if (victim.y < pusher.y + pusher.h && victim.y + victim.h > pusher.y) {
                                    const neededY = pusher.y + pusher.h;
                                    const diff = neededY - victim.y;
                                    if (diff > 0) {
                                        victim.y += diff;
                                        const vPageIndex = Math.floor(victim.y / ROWS);
                                        const vPageEnd = (vPageIndex + 1) * ROWS;
                                        if (victim.y + victim.h > vPageEnd) {
                                            const vPageStart = vPageIndex * ROWS;
                                            if (victim.y !== vPageStart) {
                                                victim.y = (vPageIndex + 1) * ROWS;
                                            }
                                        }
                                        pushDown(victim.id);
                                    }
                                }
                            }
                        });
                    };

                    pushDown(block.id);
                    return newBlocks;
                });
            };

            const add = (type) => {
                setSidebarOpen(false);
                let w=4, h=2, data={};
                const qNum = blocks.filter(b=>['mcq','short','tf'].includes(b.type)).length + 1;

                if(type==='header'){w=18;h=5; data={inst:'', title:'', logo:null};}
                else if(type==='text'){w=18;h=1; data={text:''};} 
                else if(type==='line'){w=18;h=1; data={};}
                else if(type==='image'){w=6;h=6; data={src:null};}
                else if(type==='mcq'){w=18;h=1; data={num:qNum+'.', q:'', opts:['']};} 
                else if(type==='short'){w=18;h=2; data={num:qNum+'.', q:''};} 
                else if(type==='tf'){w=18;h=1; data={num:qNum+'.', q:''};} 

                let y = 0;
                let found = false;
                while(!found && y < ROWS*10) {
                    if (getPage(y) !== getPage(y + h - 1)) {
                        y = (getPage(y) + 1) * ROWS;
                        continue;
                    }
                    for(let x=0; x<=COLS-w; x++) {
                        let hit = false;
                        for(let b of blocks) {
                            if(x < b.x + b.w && x + w > b.x && y < b.y + b.h && y + h > b.y) { hit = true; break; }
                        }
                        if(!hit) {
                            setBlocks([...blocks, { id:Date.now(), type, x, y, w, h, data }]);
                            found = true;
                            break;
                        }
                    }
                    if (!found) y++;
                }
            };

            const updateBlock = (id, partial) => setBlocks(prev => prev.map(b => b.id===id ? {...b, ...partial} : b));
            const removeBlock = (id) => setBlocks(prev => prev.filter(b => b.id!==id));

            const startDrag = (e, id, mode) => {
                e.preventDefault(); 
                if(e.type==='touchstart') return;
                const b = blocks.find(x=>x.id===id);
                setDrag({ 
                    active: true, 
                    id, 
                    mode, 
                    startX: e.clientX, 
                    startY: e.clientY, 
                    origX: b.x, 
                    origY: b.y, 
                    origW: b.w, 
                    origH: b.h,
                    resizeW: b.w,
                    resizeH: b.h,
                    snapX: b.x,
                    snapY: b.y,
                    deltaX: 0, 
                    deltaY: 0,
                    isValid: true,
                    collidingIds: []
                });
            };

            useEffect(() => {
                const move = (e) => {
                    if(!drag.active) return;
                    e.preventDefault();
                    
                    const dX = e.clientX - drag.startX;
                    const dY = e.clientY - drag.startY;
                    const gridDx = Math.round(dX / (CELL * zoom));
                    const gridDy = Math.round(dY / (CELL * zoom));

                    let valid = true;
                    const collisions = [];
                    const otherBlocks = blocks.filter(b => b.id !== drag.id);

                    if(drag.mode === 'move') {
                        let nx = Math.max(0, Math.min(COLS - drag.origW, drag.origX + gridDx));
                        let ny = Math.max(0, drag.origY + gridDy); 
                        
                        const startPage = Math.floor(ny / ROWS);
                        const endPage = Math.floor((ny + drag.origH - 1) / ROWS);
                        if(startPage !== endPage) {
                            const nextPageStart = endPage * ROWS;
                            const prevPageEnd = nextPageStart - drag.origH;
                            if(Math.abs(ny - nextPageStart) < Math.abs(ny - prevPageEnd)) ny = nextPageStart;
                            else ny = prevPageEnd;
                        }

                        for(let ob of otherBlocks) {
                            const isOver = !(
                                nx + drag.origW <= ob.x || 
                                nx >= ob.x + ob.w || 
                                ny + drag.origH <= ob.y || 
                                ny >= ob.y + ob.h
                            );
                            if(isOver) { 
                                valid = false; 
                                collisions.push(ob.id);
                            }
                        }

                        setDrag(prev => ({
                            ...prev, 
                            deltaX: dX, 
                            deltaY: dY,
                            snapX: nx,
                            snapY: ny,
                            isValid: valid,
                            collidingIds: collisions
                        }));

                    } else {
                        let nw = Math.max(1, Math.min(COLS - drag.origX, drag.origW + gridDx));
                        let nh = Math.max(1, drag.origH + gridDy);
                        const b = blocks.find(x => x.id === drag.id);
                        if(b.type === 'line') nh = 1;

                        const p = Math.floor(drag.origY / ROWS);
                        const maxH = ((p+1)*ROWS) - drag.origY;
                        nh = Math.min(nh, maxH, ROWS);

                        for(let ob of otherBlocks) {
                            const isOver = !(
                                drag.origX + nw <= ob.x || 
                                drag.origX >= ob.x + ob.w || 
                                drag.origY + nh <= ob.y || 
                                drag.origY >= ob.y + ob.h
                            );
                            if(isOver) { 
                                valid = false; 
                                collisions.push(ob.id);
                            }
                        }

                        setDrag(prev => ({
                            ...prev,
                            resizeW: nw,
                            resizeH: nh,
                            isValid: valid,
                            collidingIds: collisions
                        }));
                    }
                };
                
                const up = () => {
                    if(drag.active) {
                        if(drag.isValid) {
                            if (drag.mode === 'move') {
                                updateBlock(drag.id, {x: drag.snapX, y: drag.snapY});
                            } else {
                                const isOverflowing = overflowMap[drag.id];
                                if (!isOverflowing) {
                                    updateBlock(drag.id, {w: drag.resizeW, h: drag.resizeH});
                                }
                            }
                        }
                    }
                    setDrag(prev => ({...prev, active:false, collidingIds: []}));
                };

                if(drag.active) {
                    window.addEventListener('mousemove', move);
                    window.addEventListener('mouseup', up);
                }
                return () => { window.removeEventListener('mousemove', move); window.removeEventListener('mouseup', up); }
            }, [drag, blocks, zoom, overflowMap]);

            const doExport = async () => {
                setExporting(true);
                setSidebarOpen(false);
                const oldZoom = zoom;
                setZoom(1);
                await new Promise(r => setTimeout(r, 500)); 

                const pdf = new window.jspdf.jsPDF('p', 'mm', 'a4');
                const pages = document.querySelectorAll('.a4-page');
                
                for(let i=0; i<pages.length; i++) {
                    const cvs = await html2canvas(pages[i], { scale: 2, useCORS: true, backgroundColor:'#fff' });
                    if(i>0) pdf.addPage();
                    pdf.addImage(cvs.toDataURL('image/jpeg', 0.9), 'JPEG', 0, 0, 210, 297);
                }
                pdf.save(title + '.pdf');
                setZoom(oldZoom);
                setExporting(false);
            };

            return (
                <div className={`app-shell ${exporting?'exporting':''}`}>
                    <div className="main-area">
                        <div className="top-bar">
                            <input className="doc-title" value={title} onChange={e=>setTitle(e.target.value)} />
                        </div>
                        
                        <div className="viewport" ref={containerRef}>
                            <div className="zoom-outer-container" style={{ minHeight: (A4_H + PAGE_GAP) * totalPages * zoom }}>
                                <div className="pages-scale-wrapper" style={{ transform: `scale(${zoom})`, fontFamily: docStyle.font, fontSize: (16 * (docStyle.size / 100)) + 'px' }}>
                                    {Array.from({length: totalPages}).map((_, i) => (
                                        <div key={i} className="a4-page" style={{padding: `${MARGIN_Y}px ${MARGIN_X}px`}}>
                                            <div className="relative w-full h-full">
                                                <GridLayer blocks={blocks} pageIndex={i} draggingBlockId={drag.active ? drag.id : null} />
                                                
                                                {blocks.filter(b => {
                                                    const start = b.y; const end = b.y + b.h;
                                                    const pageStart = i*ROWS; const pageEnd = (i+1)*ROWS;
                                                    return start < pageEnd && end > pageStart && b.id !== drag.id;
                                                }).map(b => (
                                                    <div key={'occ-'+b.id} className="occupied-space" style={{
                                                        left: b.x*CELL, top: (b.y - i*ROWS)*CELL,
                                                        width: b.w*CELL, height: b.h*CELL
                                                    }}/>
                                                ))}

                                                {drag.active && drag.mode === 'move' && (() => {
                                                    const start = drag.snapY; const end = drag.snapY + drag.origH;
                                                    const pageStart = i*ROWS; const pageEnd = (i+1)*ROWS;
                                                    if(start < pageEnd && end > pageStart) {
                                                        return (
                                                            <div className={`snap-ghost ${!drag.isValid ? 'invalid' : ''}`} style={{
                                                                left: drag.snapX*CELL, top: (drag.snapY - i*ROWS)*CELL,
                                                                width: drag.origW*CELL, height: drag.origH*CELL
                                                            }}/>
                                                        );
                                                    }
                                                })()}

                                                {blocks.filter(b => {
                                                    const start = b.y; const end = b.y + b.h;
                                                    const pageStart = i * ROWS; const pageEnd = (i + 1) * ROWS;
                                                    return start < pageEnd && end > pageStart;
                                                }).map(b => {
                                                    const isActive = drag.active && drag.id === b.id;
                                                    const isColliding = drag.active && drag.collidingIds.includes(b.id);
                                                    const isOverflow = overflowMap[b.id] && isActive;
                                                    const isInvalid = isActive && (!drag.isValid || isOverflow);
                                                    let displayX = b.x, displayY = b.y, displayW = b.w, displayH = b.h, styleOverride = {};

                                                    if (isActive) {
                                                        if (drag.mode === 'move') {
                                                            const startPixelY = (drag.origY - (i * ROWS)) * CELL; 
                                                            const startPixelX = drag.origX * CELL;
                                                            styleOverride = {
                                                                left: startPixelX,
                                                                top: startPixelY,
                                                                transform: `translate(${drag.deltaX / zoom}px, ${drag.deltaY / zoom}px) scale(1.05)`,
                                                                zIndex: 999, transition: 'none', opacity: 0.9 
                                                            };
                                                        } else if (drag.mode === 'resize') {
                                                            displayW = drag.resizeW; displayH = drag.resizeH;
                                                            styleOverride = { zIndex: 999, transition: 'none' }
                                                        }
                                                    }

                                                    const contentBlockProps = isActive && drag.mode === 'resize' ? { ...b, w: drag.resizeW, h: drag.resizeH } : b;
                                                    const maxAvailableH = getMaxHeight(b);

                                                    return (
                                                        <div 
                                                            key={b.id} 
                                                            className={`block-wrapper ${isActive ? 'dragging' : ''} ${isInvalid ? 'invalid' : ''} ${isColliding ? 'collision-highlight' : ''} ${drag.active && !isActive && !isColliding ? 'scale-[0.98] opacity-90' : ''}`}
                                                            style={{
                                                                left: displayX * CELL,
                                                                top: (displayY - i*ROWS) * CELL,
                                                                width: displayW * CELL,
                                                                height: displayH * CELL,
                                                                ...styleOverride 
                                                            }}
                                                        >
                                                            {/* mask to hide dots, with the SAME rounding as the block & ghost */}
                                                            <div style={{
                                                                position: 'absolute',
                                                                inset: 0,
                                                                backgroundColor: 'white',
                                                                zIndex: -1,
                                                                borderRadius: '12px'
                                                            }} />

                                                            <div className="drag-handle" onMouseDown={e=>{e.stopPropagation(); startDrag(e, b.id, 'move')}}><MatIcon name="drag_indicator"/></div>
                                                            <div className="delete-btn" onClick={()=>removeBlock(b.id)}><MatIcon name="close"/></div>
                                                            <BlockContent b={contentBlockProps} update={updateBlock} fontSizeMultiplier={docStyle.size} handleAutoResize={handleAutoResize} isResizing={isActive && drag.mode === 'resize'} setContentOverflow={handleContentOverflow} maxAvailableH={maxAvailableH} />
                                                            <div className={`resize-handle ${b.type==='line'?'resize-handle-h':''}`} onMouseDown={e=>{e.stopPropagation(); startDrag(e, b.id, 'resize')}}></div>
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                            <div className="absolute bottom-8 w-full left-0 text-center text-base font-medium text-black">{i+1} / {totalPages}</div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    </div>

                    <button className="fab" onClick={()=>setSidebarOpen(!sidebarOpen)}>
                        <MatIcon name={sidebarOpen ? "close" : "add"} />
                    </button>

                    <div className={`sidebar ${sidebarOpen ? 'open' : ''}`}>
                        <div className="flex items-center gap-2 font-normal text-xl px-2 mb-2">
                            <MatIcon name="school" className="text-purple-700"/>
                            <span className="text-black">Wonderxam</span>
                        </div>
                        <button className="btn-primary" onClick={doExport} disabled={exporting}>
                            <MatIcon name="download"/> {exporting ? 'Exporting...' : 'Download PDF'}
                        </button>

                        <div className="overflow-y-auto flex-1 flex flex-col gap-4 pr-1">
                            <div className="bg-gray-50 p-3 rounded-xl border border-gray-200">
                                <div className="text-xs font-bold text-gray-500 uppercase mb-2">Document Style</div>
                                <select className="w-full p-2 rounded border border-gray-300 bg-white mb-3 text-sm" 
                                    value={docStyle.font} onChange={e=>setDocStyle({...docStyle, font:e.target.value})}>
                                    {FONTS.map(f => <option key={f.name} value={f.val}>{f.name}</option>)}
                                </select>
                                <div className="flex items-center justify-between">
                                    <span className="text-sm font-medium">Font Size:</span>
                                    <select 
                                        className="p-1 rounded border border-gray-300 bg-white text-sm"
                                        value={docStyle.size} 
                                        onChange={e=>setDocStyle({...docStyle, size:Number(e.target.value)})}
                                    >
                                        {FONT_SIZES.map(s => (
                                            <option key={s.label} value={s.val}>{s.label}</option>
                                        ))}
                                    </select>
                                </div>
                            </div>

                            <div>
                                <div className="text-xs font-bold text-gray-500 uppercase mb-2">Structure</div>
                                <button className="tool-btn" onClick={()=>add('header')}><MatIcon name="title"/> Header</button>
                                <button className="tool-btn" onClick={()=>add('text')}><MatIcon name="notes"/> Text Block</button>
                                <button className="tool-btn" onClick={()=>add('line')}><MatIcon name="remove"/> Divider Line</button>
                                <button className="tool-btn" onClick={()=>add('image')}><MatIcon name="image"/> Image</button>
                            </div>

                            <div>
                                <div className="text-xs font-bold text-gray-500 uppercase mb-2">Questions</div>
                                <button className="tool-btn" onClick={()=>add('mcq')}><MatIcon name="list"/> Multiple Choice</button>
                                <button className="tool-btn" onClick={()=>add('short')}><MatIcon name="short_text"/> Short Answer</button>
                                <button className="tool-btn" onClick={()=>add('tf')}><MatIcon name="check_circle"/> True / False</button>
                            </div>
                        </div>
                        
                        <div className="mt-auto pt-4 border-t border-gray-200 flex items-center justify-center gap-2 opacity-80">
                            <svg className="h-4 w-6 text-brand-copper" viewBox="0 0 100 60" fill="none" stroke="currentColor" strokeWidth="4">
                                <path d="M5 55 L50 10 L95 55" strokeLinecap="round" strokeLinejoin="round"/>
                            </svg>
                            <span className="font-logo text-xs text-gray-500 tracking-tight lowercase">inhouse software</span>
                        </div>
                    </div>
                </div>
            );
        };

        const HomeScreen = ({ onStart }) => {
            const [showModal, setShowModal] = useState(false);
            const [examName, setExamName] = useState('');

            const handleCreate = () => {
                if (examName.trim()) {
                    onStart(examName);
                } else {
                    onStart("Untitled Exam");
                }
            };

            return (
                <div id="homeScreen">
                    <div className="texture-layer"></div>
                    <div id="bg-light-caster"></div>

                    <div className="home-content">
                        <span className="material-symbols-rounded home-icon">school</span>
                        <h1 className="home-title">Wonderxam</h1>
                        <p className="home-sub">Create, Edit & Export Exams</p>
                        
                        <button className="btn-home" onClick={() => setShowModal(true)}>
                            <span className="material-symbols-rounded">add</span>
                            New Exam
                        </button>
                    </div>

                    <div className="inhouse-badge">
                        <svg viewBox="0 0 100 60">
                            <path d="M5 55 L50 10 L95 55" />
                        </svg>
                        <span>inhouse software</span>
                    </div>

                    {showModal && (
                        <div className="modal-overlay">
                            <div className="modal-card">
                                <h2 className="modal-title">New Exam</h2>
                                <div className="input-group">
                                    <input 
                                        type="text" 
                                        className="mat-input" 
                                        placeholder="Untitled Exam" 
                                        autoFocus
                                        value={examName}
                                        onChange={(e) => setExamName(e.target.value)}
                                        onKeyPress={(e) => e.key === 'Enter' && handleCreate()}
                                    />
                                    <span className="input-label">Exam Name</span>
                                </div>
                                <div className="modal-actions">
                                    <button className="btn-text" onClick={() => setShowModal(false)}>Cancel</button>
                                    <button className="btn-fill" onClick={handleCreate}>Create</button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        function App() {
            const [view, setView] = useState('home');
            const [initialTitle, setInitialTitle] = useState("Untitled Exam");

            if (view === 'home') {
                return <HomeScreen onStart={(name) => {
                    setInitialTitle(name);
                    setView('editor');
                }} />;
            }
            return <ExamEditor initialTitle={initialTitle} />;
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
