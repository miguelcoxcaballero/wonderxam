<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Wonderxam</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'brand-copper': '#d97736',
                    },
                    fontFamily: {
                        'logo': ['"Comfortaa"', 'cursive'],
                    }
                }
            }
        }
    </script>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&family=Inconsolata:wght@400;700&family=Inter:wght@400;600&family=Lato:wght@400;700&family=Lexend:wght@300;400;600&family=Lora:ital,wght@0,400;0,600;1,400&family=Merriweather:wght@400;700&family=Montserrat:wght@400;600&family=Open+Sans:wght@400;600&family=Oswald:wght@400;600&family=Playfair+Display:wght@400;600&family=Roboto:wght@400;500;700&family=Comfortaa:wght@300;400;700&family=Google+Sans:wght@400;500;700&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,0,0" />

    <style>
        :root {
            --primary: #7c3aed; /* Purple */
            --bg: #f3f4f6;
            --surface: #ffffff;
            --text: #1f1f1f;
            --border: #e5e7eb;
            --brand-copper: #d97736;
        }

        /* Prevent scrolling on the document root */
        html, body, #root {
            margin: 0; 
            height: 100%; 
            width: 100%;
            overflow: hidden; 
            font-family: 'Roboto', sans-serif; 
            background-color: var(--bg);
            color: var(--text);
            user-select: none; 
            /* Disable pinch zoom on mobile for the app shell */
            touch-action: pan-x pan-y;
        }
        
        input, textarea {
            user-select: text;
        }

        /* --- SCROLLBAR RESTORED TO ORIGINAL STYLE --- */
        ::-webkit-scrollbar {
            width: 14px;
            height: 14px;
            background-color: transparent;
        }
        ::-webkit-scrollbar-track {
            background-color: transparent;
        }
        ::-webkit-scrollbar-thumb {
            background-color: #dadce0;
            border-radius: 8px;
            border: 4px solid transparent;
            background-clip: content-box;
            transition: background-color 0.2s;
        }
        ::-webkit-scrollbar-thumb:hover {
            background-color: #bdc1c6;
        }

        input, textarea, button, select, .katex {
            font-family: inherit;
            font-size: inherit;
            color: inherit;
        }

        .mat-icon { font-family: 'Material Symbols Rounded'; font-size: 24px; vertical-align: middle; user-select: none; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        /* App Shell */
        .app-shell { 
            display: flex; 
            width: 100%; 
            height: 100%; 
            /* overflow: hidden; */ /* REMOVED to prevent clipping of sidebar shadow */
            padding: 0; 
            gap: 0; 
            animation: fadeIn 0.4s ease-out; /* Fade in editor when it loads */
        }

        /* Main Area */
        .main-area { 
            flex: 1; 
            display: flex; 
            flex-direction: column; 
            height: 100%; 
            position: relative; 
            background: var(--bg);
            border: none;
            overflow: hidden; 
            min-width: 0; 
        }

        .top-bar { height: 64px; display: flex; align-items: center; padding: 0 24px; background: var(--bg); border-bottom: 1px solid transparent; flex-shrink: 0; z-index: 300; position: relative; }
        .top-bar::after { content: ''; position: absolute; left: 0; right: 14px; bottom: -24px; height: 24px; background: linear-gradient(to bottom, var(--bg), transparent); pointer-events: none; }
        .doc-title { font-family: 'Google Sans', sans-serif; font-size: 20px; background: transparent; border: 1px solid transparent; padding: 6px 12px; border-radius: 8px; width: 100%; max-width: 400px; outline: none; transition: 0.2s; }
        .doc-title:hover { background: white; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        .doc-title:focus { background: white; border-color: var(--primary); box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        
        /* Viewport */
        .viewport { 
            flex: 1;
            height: 100%; 
            overflow-y: auto;   /* vertical scrolling */
            overflow-x: hidden; /* hide horizontal */
            padding: 40px 0;    
            display: block; 
            width: 100%; 
            position: relative;
        }
        
        .zoom-outer-container {
            width: 100%;
            min-height: 100%;
            display: flex;
            justify-content: center;
            padding: 40px 0;
            box-sizing: border-box;
        }

        .pages-scale-wrapper { 
            display: flex; 
            flex-direction: column; 
            gap: 40px; 
            transform-origin: top center; 
        }

        .a4-page { width: 794px; height: 1123px; background: white; box-shadow: 0 2px 8px rgba(0,0,0,0.1); position: relative; overflow: visible; box-sizing: border-box; border-radius: 6px; }
        
        /* Grid Lines */
        .grid-lines { 
            position: absolute; 
            top: -10px; left: -10px; right: -10px; bottom: -10px;
            pointer-events: none; z-index: 0; 
            background-color: transparent;
            border: none; 
        }

        .snap-ghost {
            position: absolute;
            background-color: rgba(139, 92, 246, 0.2); /* Purple tint */
            border: 2px dashed var(--primary);
            border-radius: 12px;
            pointer-events: none;
            z-index: 50; 
            transition: all 0.1s;
        }
        .snap-ghost.invalid {
            background-color: rgba(239, 68, 68, 0.4); 
            border-color: #ef4444;
        }

        /* Sidebar */
        .sidebar { 
            width: 340px; 
            background: var(--surface); 
            border: 1px solid var(--border); 
            border-radius: 24px; 
            display: flex; 
            flex-direction: column; 
            z-index: 1500; /* Increased z-index to be on top */
            padding: 20px 16px; 
            gap: 16px; 
            box-shadow: 0 4px 20px rgba(0,0,0,0.08); 
            margin: 24px 16px 16px 0; 
            height: calc(100vh - 40px);
            flex-shrink: 0;
        }

        /* --- BLOCK STYLES --- */
        @keyframes blockFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .block-wrapper { 
            position: absolute; 
            background: transparent;
            border: 1px solid transparent;
            border-radius: 12px; 
            box-sizing: border-box; 
            display: flex; 
            flex-direction: column; 
            z-index: 10; 
            opacity: 0;
            animation: blockFadeIn 0.35s ease-out forwards;
            transition: box-shadow 0.2s, opacity 0.35s ease-out, transform 0.3s ease, left 0.25s cubic-bezier(0.2, 0, 0.2, 1), top 0.25s cubic-bezier(0.2, 0, 0.2, 1), width 0.2s ease-out, height 0.2s ease-out; 
            touch-action: none;
        }

        /* Image Block Specifics - Square corners */
        .block-wrapper.type-image,
        .block-wrapper.type-image .block-scale-content {
            border-radius: 0 !important;
        }

        .block-scale-content {
            width: 100%;
            height: 100%;
            background: white;
            border-radius: 12px;
            position: relative;
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.2s, border-color 0.2s;
            transform-origin: center center;
            border: 1px solid transparent;
        }

        .block-wrapper:hover .block-scale-content { 
            background-color: #fafafa; 
            border-color: #ddd; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.08); 
        }
        .block-wrapper:hover { z-index: 100; }

        .block-wrapper.dragging { 
            z-index: 1000 !important; 
            transition: top 0s, left 0s;
        }

        .block-wrapper.dragging .block-scale-content {
            box-shadow: 0 20px 40px rgba(124, 58, 237, 0.25) !important; 
            border-color: var(--primary) !important; 
            background: white;
            transform: scale(1.05);
        }
        
        .block-wrapper.invalid .block-scale-content, 
        .block-wrapper.dragging.invalid .block-scale-content {
            border-color: #ef4444 !important;
            background-color: #fff1f2 !important;
            box-shadow: 0 0 0 1px #ef4444, 0 10px 30px rgba(239, 68, 68, 0.2) !important;
        }

        .block-wrapper.active .block-scale-content { 
            border-color: var(--primary); 
            box-shadow: 0 0 0 1px var(--primary), 0 8px 24px rgba(124, 58, 237, 0.15); 
            background: white; 
        }
        .block-wrapper.active { z-index: 200; }
        
        .block-wrapper.collision-highlight .block-scale-content { 
            background-color: #fee2e2 !important; 
            border: 2px solid #fca5a5 !important; 
        }
        .block-wrapper.collision-highlight { z-index: 200 !important; }

        .drag-handle { 
            position: absolute; 
            left: -42px; 
            top: 0; 
            width: 36px; 
            height: 36px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            cursor: grab; 
            color: #9ca3af; 
            opacity: 0; 
            transition: 0.2s; 
            z-index: 50; 
            background: white; 
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            touch-action: none;
        }
        .block-wrapper:hover .drag-handle { opacity: 1; }
        .block-wrapper.dragging .drag-handle { cursor: grabbing; opacity: 1; }

        .delete-btn { 
            position: absolute; 
            right: -12px; 
            top: -12px; 
            width: 32px; 
            height: 32px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            cursor: pointer; 
            color: #6b7280; 
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px; 
            opacity: 0; 
            transition: all 0.2s cubic-bezier(0.2, 0, 0.2, 1); 
            z-index: 60; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        .delete-btn:hover { 
            color: #ef4444; 
            background: #fff1f2; 
            border-color: #fecaca;
            transform: scale(1.1);
        }
        .delete-btn .mat-icon { font-size: 18px; }
        .block-wrapper:hover .delete-btn { opacity: 1; }
        
        .resize-handle { 
            position: absolute; bottom: 0; right: 0; width: 24px; height: 24px;
            cursor: nwse-resize; opacity: 0; z-index: 50; 
            touch-action: none;
        }
        .resize-handle::after { content: ''; position: absolute; bottom: 4px; right: 4px; width: 6px; height: 6px; border-bottom: 2px solid var(--primary); border-right: 2px solid var(--primary); }
        .block-wrapper:hover .resize-handle { opacity: 1; }
        .resize-handle-h { cursor: ew-resize; }
        
        .tool-btn { width: 100%; padding: 10px 16px; border-radius: 8px; display: flex; align-items: center; gap: 12px; background: transparent; border: none; color: var(--text); font-family: 'Google Sans', sans-serif; font-size: 14px; font-weight: 500; cursor: pointer; transition: 0.2s; text-align: left; }
        .tool-btn:hover { background: #f3f4f6; }
        .tool-btn i { color: #5f6368; }

        .btn-primary { 
            width: 100%; 
            padding: 12px 20px; 
            border-radius: 12px;
            background: var(--primary); 
            color: white; 
            border: none; 
            font-family: 'Google Sans', sans-serif; 
            font-weight: 500; 
            cursor: pointer; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            gap: 8px; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); 
            transition: box-shadow 0.2s, background-color 0.2s;
        }
        .btn-primary:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            filter: brightness(1.05);
        }
        .btn-primary:active {
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
            filter: brightness(0.95);
        }
        .btn-primary:disabled { opacity: 0.7; cursor: default; }
        
        .fab { display: none; position: fixed; bottom: 24px; right: 24px; width: 56px; height: 56px; border-radius: 16px; background: var(--primary); color: white; border: none; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 1000; align-items: center; justify-content: center; cursor: pointer; }
        
        .inhouse-badge {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            opacity: 0.6;
            transition: opacity 0.2s;
            text-decoration: none;
            color: var(--text-sub); 
            user-select: none;
            pointer-events: none;
        }
        .inhouse-badge svg {
            width: 24px;
            height: 14px;
            stroke-width: 6;
            stroke: #d97736;
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        .inhouse-badge span {
            font-family: 'Comfortaa', cursive;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        /* --- HOME SCREEN STYLES --- */
        #homeScreen {
            position: absolute; inset: 0; z-index: 1000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: #fcf6f3;
            font-family: 'Roboto', sans-serif;
            animation: fadeIn 0.4s ease-out;
        }
        
        #homeScreen.exit-anim {
            animation: fadeOut 0.4s ease-out forwards;
            pointer-events: none;
        }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; }}
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; }}
        @keyframes heroEnter { from { opacity: 0; transform: translateY(30px); } to { opacity: 1; transform: translateY(0); } }
        
        @keyframes menuEnter {
            0% { opacity: 0; transform: scale(0.95) translateY(-10px); }
            100% { opacity: 1; transform: scale(1) translateY(0); }
        }
        .animate-menu { 
            animation: menuEnter 0.2s cubic-bezier(0.05, 0.7, 0.1, 1.0) forwards; 
            transform-origin: top center;
        }

        .home-content {
            text-align: center;
            display: flex; flex-direction: column; align-items: center; gap: 24px;
            animation: heroEnter 0.8s cubic-bezier(0.2, 0.0, 0, 1.0);
            width: 100%; max-width: 600px;
        }

        .home-icon { font-size: 64px; color: #7c3aed; margin-bottom: 8px; }
        .home-title { font-family: 'Google Sans', sans-serif; font-size: 44px; font-weight: 400; color: #201a17; margin: 0; }
        .home-sub { font-size: 16px; color: #50453f; margin-top: -16px; margin-bottom: 16px; }

        .btn-home {
            height: 56px; padding: 0 32px; border-radius: 28px;
            background: #7c3aed; color: #ffffff;
            border: none; font-family: 'Google Sans', sans-serif; font-size: 16px; font-weight: 500;
            cursor: pointer; display: flex; align-items: center; gap: 12px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .btn-home:hover { transform: scale(1.02); box-shadow: 0 6px 12px rgba(0,0,0,0.15); }
        .btn-home:active { transform: scale(0.98); }

        #homeScreen .inhouse-badge {
            position: absolute; bottom: 32px; left: 50%; transform: translateX(-50%);
        }

        .texture-layer {
            position: fixed; inset: 0; background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.08'/%3E%3C/svg%3E");
            opacity: 0.4; pointer-events: none; z-index: -1; mix-blend-mode: overlay;
        }
        
        #bg-light-caster {
            position: absolute; top: 50%; left: 50%; width: 400px; height: 400px;
            background: radial-gradient(circle, rgba(124, 58, 237, 0.15) 0%, transparent 70%);
            border-radius: 50%; filter: blur(60px); transform: translate(-50%, -50%); pointer-events: none; z-index: 0;
        }

        /* --- EXPORT & VISIBILITY UTILITIES --- */
        .export-only { 
            display: none;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .exporting .export-only { display: block !important; }
        .exporting .hide-on-export { display: none !important; }
        .exporting .no-export { display: none !important; }
        
        .exporting {
            color: #000000 !important;
            --text: #000000 !important;
        }
        
        .exporting * {
            color: #000000 !important;
            text-shadow: none !important;
            -webkit-font-smoothing: antialiased !important;
            -moz-osx-font-smoothing: grayscale !important;
        }

        .exporting input, 
        .exporting textarea, 
        .exporting .export-only,
        .exporting .block-scale-content {
            color: #000000 !important;
        }

        .exporting .a4-page,
        .exporting .block-wrapper,
        .exporting .block-scale-content {
            background-color: #ffffff !important;
            opacity: 1 !important;
            filter: none !important;
            box-shadow: none !important;
            border: none !important;
        }

        .exporting .block-wrapper,
        .exporting .block-scale-content {
            height: auto !important;
            overflow: visible !important;
            display: block !important;
        }

        .exporting .block-scale-content,
        .exporting .export-only {
            white-space: pre-wrap !important;
            word-break: break-word !important;
        }
        
        /* Checkbox alignment */
        .mcq-checkbox {
            margin-top: 4px;
        }

        /* LOWER THE BOXES ONLY IN EXPORTED PDF */
        .exporting .mcq-checkbox {
            margin-top: 7px !important;   /* tweak for PDF vertical alignment */
            border-color: #000 !important;
        }

        .exporting .grid-layer, 
        .exporting .snap-ghost,
        .exporting .drag-handle, 
        .exporting .delete-btn, 
        .exporting .resize-handle { 
            display: none !important; 
        }
        
        .exporting .block-wrapper,
        .exporting .block-scale-content {
            box-shadow: none !important;
            border: none !important;
            background: transparent !important;
        }

        /* --- NAMING MODAL --- */
        .modal-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 2000;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(4px);
            animation: fadeIn 0.2s ease-out;
        }
        .modal-card {
            background: white; width: 100%; max-width: 400px; padding: 24px; border-radius: 28px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            display: flex; flex-direction: column; gap: 24px;
            animation: heroEnter 0.3s var(--ease-spring);
        }
        .modal-title { font-family: 'Google Sans'; font-size: 24px; color: #1f1f1f; }
        .input-group { position: relative; }
        .mat-input {
            width: 100%; height: 56px; border: 1px solid #7c3aed;
            border-radius: 4px; background: transparent; padding: 0 16px;
            color: #1f1f1f; font-size: 16px; outline: none;
        }
        .input-label {
            position: absolute; left: 12px; top: -10px; background: white;
            padding: 0 4px; font-size: 12px; color: #7c3aed;
        }
        .modal-actions { display: flex; justify-content: flex-end; gap: 12px; }
        .btn-text {
            height: 40px; padding: 0 12px; border: none; background: transparent;
            color: #7c3aed; font-family: 'Google Sans'; font-weight: 500;
            cursor: pointer; border-radius: 20px; transition: 0.2s;
        }
        .btn-text:hover { background: rgba(124, 58, 237, 0.05); }
        .btn-fill {
            height: 40px; padding: 0 24px; border: none; border-radius: 20px;
            background: #7c3aed; color: white;
            font-family: 'Google Sans'; font-weight: 500; cursor: pointer; transition: 0.2s;
        }
        .btn-fill:hover { filter: brightness(1.1); }

        @media (max-width: 1024px) {
            .app-shell { flex-direction: column; padding: 0; gap: 0; }
            .main-area { border-radius: 0; border: none; }
            .sidebar { 
                display: none; 
                width: 100%; 
                border-radius: 24px 24px 0 0;
                border: none;
                box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
                margin: 0;
                height: auto;
            }
            .sidebar.open { 
                display: flex; 
                position: fixed; 
                bottom: 90px; 
                right: 24px; 
                width: 300px; 
                max-height: 60vh; 
                overflow-y: auto; 
                box-shadow: 0 8px 30px rgba(0,0,0,0.2); 
                animation: slideUp 0.2s ease; 
                border: 1px solid var(--border); 
                border-radius: 24px;
            }
            .fab { display: flex; }
            .top-bar { padding: 0 16px; }
            .viewport { padding: 20px 10px; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useLayoutEffect, useRef, useCallback, useMemo } = React;

        const MatIcon = ({ name, className="" }) => <span className={`mat-icon material-symbols-rounded ${className}`}>{name}</span>;

        // --- CONFIG ---
        const PX_PER_MM = 3.7795275591;
        const A4_W = 794; 
        const A4_H = 1123;
        const CELL = 37.8; // ~1cm
        const COLS = 18;
        const ROWS = 27; // Rows PER PAGE
        const MARGIN_X = (A4_W - (COLS * CELL)) / 2;
        const MARGIN_Y = (A4_H - (ROWS * CELL)) / 2;
        const PAGE_GAP = 40; // Gap between pages in px

        const FONTS = [
            { name: 'Arial (Dyslexic)', val: "Arial, sans-serif" },
            { name: 'Calibri', val: "Calibri, sans-serif" },
            { name: 'Comic Neue (Dyslexic)', val: "'Comic Neue', cursive" },
            { name: 'Inconsolata (Mono)', val: "'Inconsolata', monospace" },
            { name: 'Inter', val: "'Inter', sans-serif" },
            { name: 'Lato', val: "'Lato', sans-serif" },
            { name: 'Lexend (Dyslexic)', val: "'Lexend', sans-serif" },
            { name: 'Lora (Serif)', val: "'Lora', serif" },
            { name: 'Merriweather', val: "'Merriweather', serif" },
            { name: 'Montserrat', val: "'Montserrat', sans-serif" },
            { name: 'Open Sans', val: "'Open Sans', sans-serif" },
            { name: 'Playfair Display', val: "'Playfair Display', serif" },
            { name: 'Roboto (Sans)', val: "'Roboto', sans-serif" },
            { name: 'Times New Roman', val: "'Times New Roman', serif" },
        ];
        
        const FONT_SIZES = [
            { label: 'Small', val: 85 },
            { label: 'Normal', val: 100 },
            { label: 'Large', val: 125 }
        ];

        const CustomSelect = ({ label, value, options, onChange }) => {
            const [isOpen, setIsOpen] = useState(false);
            const [coords, setCoords] = useState({ top: 0, left: 0, width: 0 });
            const triggerRef = useRef(null);

            useEffect(() => {
                const handleResize = () => setIsOpen(false);
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            const toggleOpen = () => {
                if (!isOpen && triggerRef.current) {
                    const rect = triggerRef.current.getBoundingClientRect();
                    setCoords({
                        top: rect.bottom,
                        left: rect.left,
                        width: rect.width
                    });
                }
                setIsOpen(!isOpen);
            };

            const selectedOption = options.find(o => o.val === value) || options[0];
            const displayLabel = selectedOption.label || selectedOption.name;

            return (
                <div className="relative mb-4" ref={triggerRef}>
                    <div 
                        className={`relative bg-gray-50 border-b border-gray-300 rounded-t-md hover:bg-gray-100 transition-all cursor-pointer pt-5 pb-2 px-3 h-14 flex items-center group ${isOpen ? 'bg-gray-100 border-purple-500' : ''}`}
                        onClick={toggleOpen}
                    >
                        <label className={`absolute left-3 transition-all duration-200 pointer-events-none uppercase font-bold tracking-wide ${isOpen || value ? 'top-1.5 text-[10px] text-purple-600' : 'top-4 text-xs text-gray-500'}`}>
                            {label}
                        </label>
                        <div 
                            className="text-sm text-gray-800 font-normal truncate w-full pr-6 mt-1"
                            style={{ fontFamily: label === 'Font Family' ? value : 'inherit' }}
                        >
                            {displayLabel}
                        </div>
                        <div className={`absolute right-2 top-1/2 -translate-y-1/2 text-gray-500 transition-transform duration-200 ${isOpen ? 'rotate-180' : ''}`}>
                            <MatIcon name="arrow_drop_down" />
                        </div>
                        <div className={`absolute bottom-[-1px] left-0 h-[2px] bg-purple-600 transition-all duration-300 ${isOpen ? 'w-full' : 'w-0'}`}></div>
                    </div>

                    {isOpen && ReactDOM.createPortal(
                        <>
                            <div className="fixed inset-0 z-[1999]" onClick={() => setIsOpen(false)}></div>
                            
                            <div 
                                className="fixed z-[2000] bg-white rounded-b-lg rounded-t-sm shadow-xl max-h-60 overflow-y-auto overflow-x-hidden animate-menu origin-top border border-gray-100"
                                style={{ 
                                    top: coords.top, 
                                    left: coords.left, 
                                    width: coords.width,
                                }}
                            >
                                {options.map((opt, i) => (
                                    <div 
                                        key={i} 
                                        className={`px-4 py-3 text-sm cursor-pointer hover:bg-purple-50 transition-colors flex items-center justify-between ${opt.val === value ? 'bg-purple-50 text-purple-700 font-normal' : 'text-gray-700'}`}
                                        onClick={() => {
                                            onChange(opt.val);
                                            setIsOpen(false);
                                        }}
                                        style={{ fontFamily: label === 'Font Family' ? opt.val : 'inherit' }}
                                    >
                                        <span className="truncate">{opt.label || opt.name}</span>
                                        {opt.val === value && <MatIcon name="check" className="text-[18px] shrink-0 ml-2"/>}
                                    </div>
                                ))}
                            </div>
                        </>,
                        document.body
                    )}
                </div>
            );
        };

        const GridLayer = React.memo(({ blocks, pageIndex, draggingBlockId }) => {
            const points = useMemo(() => {
                const pts = [];
                for (let r = 0; r <= ROWS; r++) {
                    for (let c = 0; c <= COLS; c++) {
                        pts.push({ c, r });
                    }
                }
                return pts;
            }, []);

            return (
                <div className="grid-layer absolute inset-0 pointer-events-none z-0">
                    {points.map((pt, i) => {
                        const globalRow = pageIndex * ROWS + pt.r;
                        const col = pt.c;
                        
                        let isCovered = false;
                        for (let b of blocks) {
                            if (draggingBlockId && b.id === draggingBlockId) continue;
                            if (
                                col >= b.x && col <= b.x + b.w &&
                                globalRow >= b.y && globalRow <= b.y + b.h
                            ) {
                                isCovered = true;
                                break;
                            }
                        }

                        return (
                            <div 
                                key={i}
                                style={{
                                    position: 'absolute',
                                    left: pt.c * CELL - 2,
                                    top: pt.r * CELL - 2,
                                    width: 4, 
                                    height: 4, 
                                    borderRadius: '50%', 
                                    backgroundColor: '#cbd5e1',
                                    opacity: isCovered ? 0 : 1,
                                    transition: 'opacity 0.4s ease',
                                    willChange: 'opacity'
                                }}
                            />
                        );
                    })}
                </div>
            );
        });

        const RichInput = ({ value, onChange, placeholder, minH="1.2em", image, onImg, contentRef, className="" }) => {
            const innerRef = useRef(null);
            const ref = contentRef || innerRef; 

            useLayoutEffect(() => {
                if(ref.current) {
                    ref.current.style.height = 'auto';
                    ref.current.style.height = ref.current.scrollHeight + 'px';
                }
            }, [value]);

            const fileRef = useRef(null);

            return (
                <div className="w-full flex flex-col group/input relative">
                    <div className="flex-1 flex items-start gap-2">
                        <textarea 
                            ref={ref}
                            rows={1}
                            className={`w-full bg-transparent outline-none resize-none hide-on-export overflow-hidden p-0 leading-normal ${className}`}
                            placeholder={placeholder} value={value} onChange={e=>onChange(e.target.value)}
                            style={{minHeight: minH, lineHeight: '1.5em'}}
                        />
                        <div
                            className="export-only w-full leading-normal"
                            style={{
                                minHeight: minH,
                                lineHeight: '1.5em',
                                whiteSpace: 'pre-wrap',
                                wordBreak: 'break-word'
                            }}
                        >
                            {value}
                        </div>
                        
                        {onImg && (
                            <div className="absolute right-0 top-0 opacity-0 group-hover/input:opacity-100 transition no-export z-10">
                                <button onClick={()=>fileRef.current.click()} className="p-1 bg-white rounded shadow hover:text-purple-600"><MatIcon name="image"/></button>
                                <input type="file" ref={fileRef} hidden accept="image/*" onChange={e=>{if(e.target.files[0]){const r=new FileReader();r.onload=ev=>onImg(ev.target.result);r.readAsDataURL(e.target.files[0]);}}} />
                            </div>
                        )}
                    </div>
                    {image && (
                        <div className="mt-1 relative inline-block">
                            <img src={image} className="max-h-24 rounded border shadow-sm" />
                            <button onClick={()=>onImg(null)} className="absolute -top-2 -right-2 bg-white rounded-full shadow p-1 text-red-500 no-export"><MatIcon name="close"/></button>
                        </div>
                    )}
                </div>
            );
        };

        const BlockContent = ({ b, update, fontSizeMultiplier, handleAutoResize, isResizing, setContentOverflow, maxAvailableH }) => {
            const contentRef = useRef(null);
            
            useLayoutEffect(() => {
                if (!contentRef.current || ['line', 'image', 'space'].includes(b.type)) return;
                
                const timer = setTimeout(() => {
                    if (!contentRef.current) return;
                    const scrollH = contentRef.current.scrollHeight;
                    const currentHeightPx = b.h * CELL;
                    const isOverflowing = scrollH > currentHeightPx + 4;
                    
                    if (setContentOverflow) {
                        setContentOverflow(b.id, isOverflowing);
                    }

                    if (!isResizing && isOverflowing) {
                        const neededRows = Math.ceil((scrollH + 8) / CELL);
                        if (neededRows > b.h) {
                            handleAutoResize(b.id, neededRows);
                        }
                    }
                }, 10);
                return () => clearTimeout(timer);
            }, [b.data, fontSizeMultiplier, b.w, b.h, isResizing]); 

            const canAddOption = !isResizing && !(b.h >= ROWS);

            switch(b.type) {
                case 'header': return (
                    <div ref={contentRef} className="p-1 flex flex-col gap-4">
                        <div className="flex gap-3">
                            <div className="w-16 h-16 border border-dashed rounded flex items-center justify-center bg-gray-50 shrink-0 relative group">
                                {b.data.logo ? <img src={b.data.logo} className="w-full h-full object-contain"/> : <span className="text-gray-400" style={{fontSize: '0.75em'}}>LOGO</span>}
                                <input type="file" className="absolute inset-0 opacity-0 cursor-pointer" onChange={e=>{if(e.target.files[0]){const r=new FileReader();r.onload=ev=>update(b.id, {data:{...b.data, logo:ev.target.result}});r.readAsDataURL(e.target.files[0]);}}}/>
                            </div>
                            <div className="flex-1 flex flex-col gap-1">
                                <input className="font-bold bg-transparent outline-none w-full" style={{fontSize: '1.4em'}} placeholder="Institution" value={b.data.inst} onChange={e=>update(b.id, {data:{...b.data, inst:e.target.value}})}/>
                                <input className="bg-transparent outline-none w-full" style={{fontSize: '1.1em'}} placeholder="Exam Name" value={b.data.title} onChange={e=>update(b.id, {data:{...b.data, title:e.target.value}})}/>
                            </div>
                        </div>
                        <div className="grid grid-cols-2 gap-4 border-t pt-2" style={{fontSize: '0.75em'}}>
                            {['Name','Date','Class','Score'].map(l=><div key={l} className="flex gap-1"><span className="font-bold">{l}:</span><div className="flex-1 border-b border-dashed border-gray-400"></div></div>)}
                        </div>
                    </div>
                );
                case 'text': return <div className="p-1 h-full"><RichInput contentRef={contentRef} value={b.data.text} onChange={v=>update(b.id,{data:{...b.data, text:v}})} placeholder="Instructions..." /></div>;
                case 'line': return <div className="w-full h-full flex items-center justify-center px-2"><div className="w-full border-b border-black"></div></div>;
                case 'image': return (
                    <div className="w-full h-full bg-gray-50 flex items-center justify-center relative group">
                        {b.data.src ? <img src={b.data.src} className="w-full h-full object-contain"/> : <span className="text-gray-400" style={{fontSize: '0.75em'}}>Upload Image</span>}
                        {!b.data.src && <input type="file" className="absolute inset-0 opacity-0 cursor-pointer" onChange={e=>{if(e.target.files[0]){const r=new FileReader();r.onload=ev=>update(b.id,{data:{...b.data,src:ev.target.result}});r.readAsDataURL(e.target.files[0]);}}} />}
                    </div>
                );
                case 'mcq': return (
                    <div ref={contentRef} className="p-1 flex flex-col">
                        <div className="flex gap-2 mb-1 items-baseline">
                            <input className="w-6 font-bold bg-transparent outline-none text-right pt-1.5" value={b.data.num} onChange={e=>update(b.id,{data:{...b.data,num:e.target.value}})}/>
                            <div className="flex-1">
                                <RichInput 
                                    value={b.data.q} 
                                    onChange={v=>update(b.id,{data:{...b.data,q:v}})} 
                                    placeholder="Question"
                                    className="border-b border-transparent focus:border-purple-300"
                                />
                            </div>
                        </div>
                        <div className="pl-8 flex-1 flex flex-col gap-2">
                            {b.data.opts.map((o,i)=>(
                                <div key={i} className="flex items-start gap-2 group/opt">
                                    <div className="w-4 h-4 border border-gray-400 bg-white shrink-0 mcq-checkbox"></div>
                                    <span className="font-bold mt-1" style={{fontSize: '0.8em'}}>{String.fromCharCode(65+i)}.</span>
                                    <div className="flex-1">
                                        <RichInput 
                                            value={o} 
                                            onChange={v=>{const n=[...b.data.opts];n[i]=v;update(b.id,{data:{...b.data,opts:n}})}} 
                                            minH="1.2em"
                                            className="border-b border-transparent focus:border-purple-300"
                                        />
                                    </div>
                                    <button onClick={() => {
                                        const n = b.data.opts.filter((_, idx) => idx !== i);
                                        update(b.id, {data: {...b.data, opts: n}});
                                    }} className="w-7 h-7 flex items-center justify-center rounded-md bg-gray-50 hover:bg-red-50 text-gray-400 hover:text-red-500 transition-all opacity-0 group-hover/opt:opacity-100 no-export mt-0.5 ml-2 border border-gray-100 hover:border-red-200 shadow-sm">
                                        <MatIcon name="delete" className="text-[16px]" />
                                    </button>
                                </div>
                            ))}
                            <button 
                                className={`text-left no-export transition-colors ${canAddOption ? 'text-purple-600 hover:text-purple-800' : 'text-gray-400 cursor-not-allowed'}`}
                                style={{fontSize: '0.8em'}} 
                                onClick={()=>{
                                    if(canAddOption) {
                                        const n=[...b.data.opts,''];
                                        update(b.id,{data:{...b.data,opts:n}})
                                    }
                                }}
                                title={!canAddOption ? "Not enough space to add option" : "Add Option"}
                            >+ Option</button>
                        </div>
                    </div>
                );
                case 'short': return (
                    <div ref={contentRef} className="p-1 flex flex-col">
                        <div className="flex gap-2 mb-1 items-baseline">
                            <input className="w-6 font-bold bg-transparent outline-none text-right p-0 m-0 leading-[1.5em]" value={b.data.num} onChange={e=>update(b.id,{data:{...b.data,num:e.target.value}})}/>
                            <div className="flex-1"><RichInput value={b.data.q} onChange={v=>update(b.id,{data:{...b.data,q:v}})} placeholder="Question"/></div>
                        </div>
                    </div>
                );
                case 'tf': return (
                    <div ref={contentRef} className="p-1 flex flex-col">
                        <div className="flex gap-2 mb-1 items-baseline">
                            <input className="w-6 font-bold bg-transparent outline-none text-right p-0 m-0 leading-[1.5em]" value={b.data.num} onChange={e=>update(b.id,{data:{...b.data,num:e.target.value}})}/>
                            <div className="flex-1"><RichInput value={b.data.q} onChange={v=>update(b.id,{data:{...b.data,q:v}})} placeholder="Statement"/></div>
                        </div>
                        <div className="pl-8 mt-2 flex gap-6" style={{fontSize: '0.8em'}}>
                            <div className="flex items-center gap-2">
                                <div className="w-4 h-4 border border-gray-400 bg-white"></div> <span>True</span>
                            </div>
                            <div className="flex items-center gap-2">
                                <div className="w-4 h-4 border border-gray-400 bg-white"></div> <span>False</span>
                            </div>
                        </div>
                    </div>
                );
            }
        };

        const ExamEditor = ({ initialTitle }) => {
            const [blocks, setBlocks] = useState([]);
            const [docStyle, setDocStyle] = useState({ font: FONTS[0].val, size: 100 });
            const [zoom, setZoom] = useState(1);
            const [sidebarOpen, setSidebarOpen] = useState(false);
            const [exporting, setExporting] = useState(false);
            const [title, setTitle] = useState(initialTitle || "Untitled Exam");
            const [overflowMap, setOverflowMap] = useState({});

            const containerRef = useRef(null);
            
            const [drag, setDrag] = useState({ 
                active: false, 
                id: null, 
                mode: null, 
                startX: 0, 
                startY: 0, 
                origX: 0, 
                origY: 0, 
                origW: 0, 
                origH: 0,
                resizeW: 0,
                resizeH: 0,
                snapX: 0,
                snapY: 0,
                deltaX: 0, 
                deltaY: 0,
                isValid: true,
                collidingIds: [] 
            });

            const getMaxHeight = useCallback((b) => {
                const p = Math.floor(b.y / ROWS);
                const pageEnd = (p + 1) * ROWS;
                let limit = pageEnd - b.y; 
                return 1000; 
            }, [blocks]);

            useLayoutEffect(() => {
                const fit = () => {
                    if(!containerRef.current) return;
                    const w = containerRef.current.clientWidth;
                    const horizontalPadding = 40; 
                    const fullPageWidth = A4_W + horizontalPadding;

                    if (w < fullPageWidth) {
                        const rawScale = (w - horizontalPadding) / A4_W;
                        const safeScale = Math.max(0.1, rawScale * 0.97); 
                        setZoom(safeScale);
                    } else {
                        setZoom(1);
                    }
                };
                window.addEventListener('resize', fit);
                fit();
                return () => window.removeEventListener('resize', fit);
            }, []);

            const totalPages = useMemo(() => {
                let maxY = 0;
                blocks.forEach(b => { if(b.y + b.h > maxY) maxY = b.y + b.h; });
                return Math.max(1, Math.ceil(maxY / ROWS));
            }, [blocks]);

            const getPage = (y) => Math.floor(y / ROWS);

            const handleContentOverflow = useCallback((id, isOverflowing) => {
                setOverflowMap(prev => {
                    if (prev[id] === isOverflowing) return prev;
                    return { ...prev, [id]: isOverflowing };
                });
            }, []);

            const handleAutoResize = (id, newH) => {
                const clampedH = Math.min(newH, ROWS);
                
                setBlocks(prev => {
                    const idx = prev.findIndex(b => b.id === id);
                    if(idx === -1) return prev;
                    
                    const b = prev[idx];
                    if(b.h === clampedH) return prev;

                    const newBlocks = JSON.parse(JSON.stringify(prev));
                    const block = newBlocks[idx];
                    block.h = clampedH;
                    
                    const currentRow = block.y;
                    const pageIndex = Math.floor(currentRow / ROWS);
                    const pageStart = pageIndex * ROWS;
                    const pageEnd = (pageIndex + 1) * ROWS;
                    
                    if (currentRow + clampedH > pageEnd) {
                        if (currentRow !== pageStart) {
                             block.y = (pageIndex + 1) * ROWS;
                        }
                    }

                    const pushDown = (pusherId) => {
                        const pusher = newBlocks.find(x => x.id === pusherId);
                        
                        newBlocks.forEach(victim => {
                            if (victim.id === pusher.id) return;
                            const isHorizOverlapping = !(victim.x + victim.w <= pusher.x || victim.x >= pusher.x + pusher.w);
                            if (isHorizOverlapping) {
                                if (victim.y < pusher.y + pusher.h && victim.y + victim.h > pusher.y) {
                                    const neededY = pusher.y + pusher.h;
                                    const diff = neededY - victim.y;
                                    if (diff > 0) {
                                        victim.y += diff;
                                        const vPageIndex = Math.floor(victim.y / ROWS);
                                        const vPageEnd = (vPageIndex + 1) * ROWS;
                                        if (victim.y + victim.h > vPageEnd) {
                                            const vPageStart = vPageIndex * ROWS;
                                            if (victim.y !== vPageStart) {
                                                victim.y = (vPageIndex + 1) * ROWS;
                                            }
                                        }
                                        pushDown(victim.id);
                                    }
                                }
                            }
                        });
                    };

                    pushDown(block.id);
                    return newBlocks;
                });
            };

            const add = (type) => {
                setSidebarOpen(false);
                let w=4, h=2, data={};
                const qNum = blocks.filter(b=>['mcq','short','tf'].includes(b.type)).length + 1;

                if(type==='header'){w=18;h=5; data={inst:'', title:'', logo:null};}
                else if(type==='text'){w=18;h=1; data={text:''};} 
                else if(type==='line'){w=18;h=1; data={};}
                else if(type==='image'){w=6;h=6; data={src:null};}
                else if(type==='mcq'){w=18;h=1; data={num:qNum+'.', q:'', opts:['']};} 
                else if(type==='short'){w=18;h=2; data={num:qNum+'.', q:''};} 
                else if(type==='tf'){w=18;h=1; data={num:qNum+'.', q:''};} 

                let y = 0;
                let found = false;
                while(!found && y < ROWS*10) {
                    if (getPage(y) !== getPage(y + h - 1)) {
                        y = (getPage(y) + 1) * ROWS;
                        continue;
                    }
                    for(let x=0; x<=COLS-w; x++) {
                        let hit = false;
                        for(let b of blocks) {
                            if(x < b.x + b.w && x + w > b.x && y < b.y + b.h && y + h > b.y) { hit = true; break; }
                        }
                        if(!hit) {
                            setBlocks([...blocks, { id:Date.now(), type, x, y, w, h, data }]);
                            found = true;
                            break;
                        }
                    }
                    if (!found) y++;
                }
            };

            const updateBlock = (id, partial) => setBlocks(prev => prev.map(b => b.id===id ? {...b, ...partial} : b));
            const removeBlock = (id) => setBlocks(prev => prev.filter(b => b.id!==id));

            const getPointerPos = (e) => {
                if(e.touches && e.touches.length > 0) {
                    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
                return { x: e.clientX, y: e.clientY };
            };

            const startDrag = (e, id, mode) => {
                if (e.cancelable) e.preventDefault();
                e.stopPropagation();

                const pos = getPointerPos(e);
                const b = blocks.find(x=>x.id===id);
                setDrag({ 
                    active: true, 
                    id, 
                    mode, 
                    startX: pos.x, 
                    startY: pos.y, 
                    origX: b.x, 
                    origY: b.y, 
                    origW: b.w, 
                    origH: b.h,
                    resizeW: b.w,
                    resizeH: b.h,
                    snapX: b.x, 
                    snapY: b.y, 
                    deltaX: 0, 
                    deltaY: 0,
                    isValid: true,
                    collidingIds: [] 
                });
            };

            useEffect(() => {
                const move = (e) => {
                    if(!drag.active) return;
                    if (e.cancelable) e.preventDefault();
                    
                    const pos = getPointerPos(e);
                    
                    const dX = pos.x - drag.startX;
                    const dY = pos.y - drag.startY;
                    const gridDx = Math.round(dX / (CELL * zoom));
                    const gridDy = Math.round(dY / (CELL * zoom));

                    let valid = true;
                    const collisions = [];
                    const otherBlocks = blocks.filter(b => b.id !== drag.id);

                    if(drag.mode === 'move') {
                        let nx = Math.max(0, Math.min(COLS - drag.origW, drag.origX + gridDx));
                        let ny = Math.max(0, drag.origY + gridDy); 
                        
                        const startPage = Math.floor(ny / ROWS);
                        const endPage = Math.floor((ny + drag.origH - 1) / ROWS);
                        if(startPage !== endPage) {
                            const nextPageStart = endPage * ROWS;
                            const prevPageEnd = nextPageStart - drag.origH;
                            if(Math.abs(ny - nextPageStart) < Math.abs(ny - prevPageEnd)) ny = nextPageStart;
                            else ny = prevPageEnd;
                        }

                        for(let ob of otherBlocks) {
                            const isOver = !(
                                nx + drag.origW <= ob.x || 
                                nx >= ob.x + ob.w || 
                                ny + drag.origH <= ob.y || 
                                ny >= ob.y + ob.h
                            );
                            if(isOver) { 
                                valid = false; 
                                collisions.push(ob.id);
                            }
                        }

                        setDrag(prev => ({
                            ...prev, 
                            deltaX: dX, 
                            deltaY: dY,
                            snapX: nx,
                            snapY: ny,
                            isValid: valid,
                            collidingIds: collisions
                        }));

                    } else {
                        const b = blocks.find(x => x.id === drag.id);
                        
                        let reqMinW = 1;
                        let reqMinH = 1;
                        
                        if (b.type === 'header') {
                            reqMinW = 6;
                            reqMinH = 4;
                        }

                        let nw = Math.max(1, Math.min(COLS - drag.origX, drag.origW + gridDx));
                        let nh = Math.max(1, drag.origH + gridDy);
                        
                        if(b.type === 'line') nh = 1;

                        const p = Math.floor(drag.origY / ROWS);
                        const maxH = ((p+1)*ROWS) - drag.origY;
                        nh = Math.min(nh, maxH, ROWS);

                        for(let ob of otherBlocks) {
                            const isOver = !(
                                drag.origX + nw <= ob.x || 
                                drag.origX >= ob.x + ob.w || 
                                drag.origY + nh <= ob.y || 
                                drag.origY >= ob.y + ob.h
                            );
                            if(isOver) { 
                                valid = false; 
                                collisions.push(ob.id);
                            }
                        }

                        if (nw < reqMinW || nh < reqMinH) {
                            valid = false;
                        }

                        setDrag(prev => ({
                            ...prev,
                            resizeW: nw,
                            resizeH: nh,
                            isValid: valid,
                            collidingIds: collisions
                        }));
                    }
                };
                
                const up = () => {
                    if(drag.active) {
                        if (drag.mode === 'move') {
                            if(drag.isValid) {
                                updateBlock(drag.id, {x: drag.snapX, y: drag.snapY});
                            }
                        } else {
                            const b = blocks.find(x => x.id === drag.id);
                            let reqMinW = 1; let reqMinH = 1;
                            if (b.type === 'header') { reqMinW = 6; reqMinH = 4; }

                            const finalW = Math.max(drag.resizeW, reqMinW);
                            const finalH = Math.max(drag.resizeH, reqMinH);

                            const otherBlocks = blocks.filter(x => x.id !== drag.id);
                            let hasCollision = false;
                            
                            for(let ob of otherBlocks) {
                                const isOver = !(
                                    b.x + finalW <= ob.x || 
                                    b.x >= ob.x + ob.w || 
                                    b.y + finalH <= ob.y || 
                                    b.y >= ob.y + ob.h
                                );
                                if(isOver) { hasCollision = true; break; }
                            }

                            if (!hasCollision) {
                                updateBlock(drag.id, {w: finalW, h: finalH});
                            }
                        }
                    }
                    setDrag(prev => ({...prev, active:false, collidingIds: []}));
                };

                if(drag.active) {
                    window.addEventListener('mousemove', move);
                    window.addEventListener('mouseup', up);
                    window.addEventListener('touchmove', move, { passive: false });
                    window.addEventListener('touchend', up);
                }
                return () => { 
                    window.removeEventListener('mousemove', move); 
                    window.removeEventListener('mouseup', up);
                    window.removeEventListener('touchmove', move);
                    window.removeEventListener('touchend', up);
                }
            }, [drag, blocks, zoom, overflowMap]);

            const doExport = async () => {
                setExporting(true);
                setSidebarOpen(false);
                const oldZoom = zoom;
                setZoom(1);
                await new Promise(r => setTimeout(r, 500)); 

                const pdf = new window.jspdf.jsPDF('p', 'mm', 'a4');
                const pages = document.querySelectorAll('.a4-page');
                
                for(let i=0; i<pages.length; i++) {
                    const cvs = await html2canvas(pages[i], { 
                        scale: 4, 
                        useCORS: true, 
                        backgroundColor:'#ffffff',
                        logging: false
                    });
                    
                    if(i>0) pdf.addPage();
                    pdf.addImage(cvs.toDataURL('image/png'), 'PNG', 0, 0, 210, 297);
                }
                pdf.save(title + '.pdf');
                setZoom(oldZoom);
                setExporting(false);
            };

            return (
                <div className={`app-shell ${exporting?'exporting':''}`}>
                    <div className="main-area">
                        <div className="top-bar">
                            <input className="doc-title" value={title} onChange={e=>setTitle(e.target.value)} />
                        </div>
                        
                        <div className="viewport" ref={containerRef}>
                            <div className="zoom-outer-container" style={{ minHeight: (A4_H + PAGE_GAP) * totalPages * zoom }}>
                                <div className="pages-scale-wrapper" style={{ transform: `scale(${zoom})`, fontFamily: docStyle.font, fontSize: (16 * (docStyle.size / 100)) + 'px' }}>
                                    {Array.from({length: totalPages}).map((_, i) => (
                                        <div key={i} className="a4-page" style={{padding: `${MARGIN_Y}px ${MARGIN_X}px`}}>
                                            <div className="relative w-full h-full">
                                                <GridLayer blocks={blocks} pageIndex={i} draggingBlockId={drag.active ? drag.id : null} />

                                                {drag.active && drag.mode === 'move' && (() => {
                                                    const start = drag.snapY; const end = drag.snapY + drag.origH;
                                                    const pageStart = i*ROWS; const pageEnd = (i+1)*ROWS;
                                                    if(start < pageEnd && end > pageStart) {
                                                        return (
                                                            <div className={`snap-ghost ${!drag.isValid ? 'invalid' : ''}`} style={{
                                                                left: drag.snapX*CELL, top: (drag.snapY - i*ROWS)*CELL,
                                                                width: drag.origW*CELL, height: drag.origH*CELL
                                                            }}/>
                                                        );
                                                    }
                                                })()}

                                                {blocks.filter(b => {
                                                    const start = b.y; const end = b.y + b.h;
                                                    const pageStart = i * ROWS; const pageEnd = (i + 1) * ROWS;
                                                    return start < pageEnd && end > pageStart;
                                                }).map(b => {
                                                    const isActive = drag.active && drag.id === b.id;
                                                    const isColliding = drag.active && drag.collidingIds.includes(b.id);
                                                    const isOverflow = overflowMap[b.id] && isActive;
                                                    const isInvalid = isActive && (!drag.isValid || isOverflow);
                                                    let displayX = b.x, displayY = b.y, displayW = b.w, displayH = b.h, styleOverride = {};

                                                    if (isActive) {
                                                        if (drag.mode === 'move') {
                                                            const startPixelY = (drag.origY - (i * ROWS)) * CELL; 
                                                            const startPixelX = drag.origX * CELL;
                                                            
                                                            styleOverride = {
                                                                left: startPixelX + (drag.deltaX / zoom),
                                                                top: startPixelY + (drag.deltaY / zoom),
                                                                zIndex: 999, 
                                                                transition: 'none',
                                                                opacity: 0.9 
                                                            };
                                                        } else if (drag.mode === 'resize') {
                                                            displayW = drag.resizeW; displayH = drag.resizeH;
                                                            styleOverride = { zIndex: 999, transition: 'none' }
                                                        }
                                                    }

                                                    const contentBlockProps = isActive && drag.mode === 'resize' ? { ...b, w: drag.resizeW, h: drag.resizeH } : b;
                                                    const maxAvailableH = getMaxHeight(b);

                                                    return (
                                                        <div 
                                                            key={b.id} 
                                                            className={`block-wrapper ${b.type === 'image' ? 'type-image' : ''} ${isActive ? 'dragging' : ''} ${isInvalid ? 'invalid' : ''} ${isColliding ? 'collision-highlight' : ''} ${drag.active && !isActive && !isColliding ? 'scale-[0.98] opacity-90' : ''}`}
                                                            style={{
                                                                left: displayX * CELL,
                                                                top: (displayY - i*ROWS) * CELL,
                                                                width: displayW * CELL,
                                                                height: displayH * CELL,
                                                                ...styleOverride 
                                                            }}
                                                        >
                                                            <div className="block-scale-content">
                                                                <div className="drag-handle" onMouseDown={e=>startDrag(e, b.id, 'move')} onTouchStart={e=>startDrag(e, b.id, 'move')}>
                                                                    <MatIcon name="drag_indicator"/>
                                                                </div>
                                                                <div className="delete-btn" onClick={()=>removeBlock(b.id)}>
                                                                    <MatIcon name="delete"/>
                                                                </div>
                                                                <BlockContent b={contentBlockProps} update={updateBlock} fontSizeMultiplier={docStyle.size} handleAutoResize={handleAutoResize} isResizing={isActive && drag.mode === 'resize'} setContentOverflow={handleContentOverflow} maxAvailableH={maxAvailableH} />
                                                                <div className={`resize-handle ${b.type==='line'?'resize-handle-h':''}`} onMouseDown={e=>startDrag(e, b.id, 'resize')} onTouchStart={e=>startDrag(e, b.id, 'resize')}></div>
                                                            </div>
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                            <div className="absolute bottom-8 w-full left-0 text-center text-base font-medium text-black">{i+1} / {totalPages}</div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    </div>

                    <button className="fab" onClick={()=>setSidebarOpen(!sidebarOpen)}>
                        <MatIcon name={sidebarOpen ? "close" : "add"} />
                    </button>

                    <div className={`sidebar ${sidebarOpen ? 'open' : ''}`}>
                        <div className="flex items-center gap-2 font-normal text-xl px-2 mb-2">
                            <MatIcon name="school" className="text-purple-700"/>
                            <span className="text-black">Wonderxam</span>
                        </div>
                        <button className="btn-primary" onClick={doExport} disabled={exporting}>
                            <MatIcon name="download"/> {exporting ? 'Exporting...' : 'Download PDF'}
                        </button>

                        <div className="overflow-y-auto flex-1 flex flex-col gap-4 pr-1">
                            <div className="bg-gray-50 p-3 rounded-xl border border-gray-200">
                                <div className="text-xs font-bold text-gray-500 uppercase mb-3">Document Style</div>
                                
                                <CustomSelect 
                                    label="Font Family"
                                    value={docStyle.font}
                                    options={FONTS}
                                    onChange={v => setDocStyle({...docStyle, font: v})}
                                />

                                <CustomSelect 
                                    label="Font Size"
                                    value={docStyle.size}
                                    options={FONT_SIZES}
                                    onChange={v => setDocStyle({...docStyle, size: Number(v)})}
                                />
                            </div>

                            <div>
                                <div className="text-xs font-bold text-gray-500 uppercase mb-2">Structure</div>
                                <button className="tool-btn" onClick={()=>add('header')}><MatIcon name="title"/> Header</button>
                                <button className="tool-btn" onClick={()=>add('text')}><MatIcon name="notes"/> Text Block</button>
                                <button className="tool-btn" onClick={()=>add('line')}><MatIcon name="remove"/> Divider Line</button>
                                <button className="tool-btn" onClick={()=>add('image')}><MatIcon name="image"/> Image</button>
                            </div>

                            <div>
                                <div className="text-xs font-bold text-gray-500 uppercase mb-2">Questions</div>
                                <button className="tool-btn" onClick={()=>add('mcq')}><MatIcon name="list"/> Multiple Choice</button>
                                <button className="tool-btn" onClick={()=>add('short')}><MatIcon name="short_text"/> Short Answer</button>
                                <button className="tool-btn" onClick={()=>add('tf')}><MatIcon name="check_circle"/> True / False</button>
                            </div>
                        </div>
                        
                        <div className="mt-auto pt-4 border-t border-gray-200 flex items-center justify-center gap-2 opacity-80">
                            <svg className="h-4 w-6 text-brand-copper" viewBox="0 0 100 60" fill="none" stroke="currentColor" strokeWidth="4">
                                <path d="M5 55 L50 10 L95 55" strokeLinecap="round" strokeLinejoin="round"/>
                            </svg>
                            <span className="font-logo text-xs text-gray-500 tracking-tight lowercase">inhouse software</span>
                        </div>
                    </div>
                </div>
            );
        };

        const HomeScreen = ({ onStart }) => {
            const [showModal, setShowModal] = useState(false);
            const [examName, setExamName] = useState('');
            const [isExiting, setIsExiting] = useState(false);

            const handleCreate = () => {
                setIsExiting(true);
                
                setTimeout(() => {
                    if (examName.trim()) {
                        onStart(examName);
                    } else {
                        onStart("Untitled Exam");
                    }
                }, 400);
            };

            return (
                <div id="homeScreen" className={isExiting ? 'exit-anim' : ''}>
                    <div className="texture-layer"></div>
                    <div id="bg-light-caster"></div>

                    <div className="home-content">
                        <span className="material-symbols-rounded home-icon">school</span>
                        <h1 className="home-title">Wonderxam</h1>
                        <p className="home-sub">Create, Edit & Export Exams</p>
                        
                        <button className="btn-home" onClick={() => setShowModal(true)}>
                            <span className="material-symbols-rounded">add</span>
                            New Exam
                        </button>
                    </div>

                    <div className="inhouse-badge">
                        <svg viewBox="0 0 100 60">
                            <path d="M5 55 L50 10 L95 55" />
                        </svg>
                        <span>inhouse software</span>
                    </div>

                    {showModal && (
                        <div className="modal-overlay">
                            <div className="modal-card">
                                <h2 className="modal-title">New Exam</h2>
                                <div className="input-group">
                                    <input 
                                        type="text" 
                                        className="mat-input" 
                                        placeholder="Untitled Exam" 
                                        autoFocus
                                        value={examName}
                                        onChange={(e) => setExamName(e.target.value)}
                                        onKeyPress={(e) => e.key === 'Enter' && handleCreate()}
                                    />
                                    <span className="input-label">Exam Name</span>
                                </div>
                                <div className="modal-actions">
                                    <button className="btn-text" onClick={() => setShowModal(false)}>Cancel</button>
                                    <button className="btn-fill" onClick={handleCreate}>Create</button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        function App() {
            const [view, setView] = useState('home');
            const [initialTitle, setInitialTitle] = useState("Untitled Exam");

            if (view === 'home') {
                return <HomeScreen onStart={(name) => {
                    setInitialTitle(name);
                    setView('editor');
                }} />;
            }
            return <ExamEditor initialTitle={initialTitle} />;
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
